<?xml version="1.0" encoding="UTF-8"?>
 <chapter id="fdwhandler">
   <title>Écrire un wrapper de données distantes</title>

   <indexterm zone="fdwhandler">
    <primary>wrapper de données distantes</primary>
    <secondary>gestionnaire</secondary>
   </indexterm>

   <para>
    Toutes les opérations sur une table distante sont gérées via un
    wrapper de données distantes. Ce dernier est un ensemble de fonctions
    que PostgreSQL appelle. Le wrapper de données
    distantes est responsable de la récupération des données à partir de
    le source de données distante et de leur renvoi à l'exécuteur
    <productname>PostgreSQL</productname>. Ce chapitre indique comment
    écrire un nouveau wrapper de données distantes.
   </para>

   <para>
    Les wrappers de données distantes incluent dans la distribution
    standard sont de bons exemples lorsque vous essayez d'écrire les
    votres. Regardez dans le sous-répertoire
    <filename>contrib/file_fdw</filename> du répertoire des sources. La
    page de référence <xref linkend="sql-createforeigndatawrapper"/>
    contient aussi des détails utiles.
   </para>

   <note>
    <para>
     Le standard SQL spécifie une interface pour l'écriture des wrappers
     de données distantes. Néanmoins, PostgreSQL n'implémente pas cette
     API car l'effort nécessaire pour cela serait trop important. De
     toute façon, l'API standard n'est pas encore très adoptée.
    </para>
   </note>

   <sect1 id="fdw-functions">
    <title>Fonctions d'un wrapper de données distantes</title>

   <para>
    Le développeur d'un FDW doit écrire une fonction de gestion (handler)
    et, en option, une fonction de validation. Les deux fonctions doivent
    être écrites dans un langage compilé comme le C en utilisant
    l'interface version-1. Pour les détails sur les conventions d'appel
    et le chargement dynamique en langage C, voir <xref linkend="xfunc-c"/>.
   </para>

   <para>
    La fonction de gestion renvoie simplement une structure de pointeurs
    de fonctions callback qui seront appelées par le planificateur,
    l'exécuteur et différentes commandes de maintenance. La plupart du
    travail dans l'écriture d'une FDW se
    trouve dans l'implémentation de ces fonctions callback. La fonction
    de gestion doit être enregistrée dans
    <productname>PostgreSQL</productname> comme ne prenant aucun argument
    et renvoyant le pseudo-type <type>fdw_handler</type>. Les fonctions
    callback sont des fonctions en C et ne sont pas visibles ou
    appelables avec du SQL. Les fonctions callback sont décrites dans
    <xref linkend="fdw-callbacks"/>.
   </para>

   <para>
	 La fonction de validation est responsable de la validation des options
	 données dans les commandes <command>CREATE</command> et
	 <command>ALTER</command> pour son wrapper de données distantes,
	 ainsi que pour les serveurs distants, les correspondances
	 d'utilisateurs et les tables distants utilisant le wrapper. La
	 fonction de validation doit être enregistrée comme prenant deux
	 arguments&nbsp;: un tableau de texte contenant les options à
	 valider et un OID représentant le type d'objet avec lequel les
	 options sont validées (sous la forme d'un OID du catalogue système
	 où sera stocké l'objet, donc
     <literal>ForeignDataWrapperRelationId</literal>,
     <literal>ForeignServerRelationId</literal>,
     <literal>UserMappingRelationId</literal> ou
     <literal>ForeignTableRelationId</literal>).
     Si aucune fonction de validation n'est fournie, les options ne sont
     pas vérifiées au moment de la création ou de la modification de
     l'objet.
   </para>

   </sect1>

   <sect1 id="fdw-callbacks">
    <title>Routines callback des wrappers de données distantes</title>

    <para>
     La fonction de gestion d'une FDW renvoie une structure
     <structname>FdwRoutine</structname> allouée avec palloc. Elle
     contient des pointeurs vers les fonctions de callback suivantes&nbsp;:
    </para>

    <para>
<programlisting>
void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);
</programlisting>

     Obtain relation size estimates for a foreign table.  This is called
     at the beginning of planning for a query involving a foreign table.
     <literal>root</literal> is the planner's global information about the query;
     <literal>baserel</literal> is the planner's information about this table; and
      <literal>foreigntableid</literal> is the <structname>pg_class</structname> OID of the
     foreign table.  (<literal>foreigntableid</literal> could be obtained from the
     planner data structures, but it's passed explicitly to save effort.)
     </para>
 
     <para>
     This function should update <literal>baserel-&gt;rows</literal> to be the
     expected number of rows returned by the table scan, after accounting for
     the filtering done by the restriction quals.  The initial value of
     <literal>baserel-&gt;rows</literal> is just a constant default estimate, which
     should be replaced if at all possible.  The function may also choose to
     update <literal>baserel-&gt;width</literal> if it can compute a better estimate
     of the average result row width.
    </para>

    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>

    <para>
<programlisting>
void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);
</programlisting>

     Create possible access paths for a scan on a foreign table.
     This is called during query planning.
     The parameters are the same as for <function>GetForeignRelSize</function>,
     which has already been called.
    </para>

    <para>
     This function must generate at least one access path
     (<structname>ForeignPath</structname> node) for a scan on the foreign table and
     must call <function>add_path</function> to add each such path to
     <literal>baserel-&gt;pathlist</literal>.  It's recommended to use
     <function>create_foreignscan_path</function> to build the
     <structname>ForeignPath</structname> nodes.  The function can generate multiple
     access paths, e.g., a path which has valid <literal>pathkeys</literal> to
     represent a pre-sorted result.  Each access path must contain cost
     estimates, and can contain any FDW-private information that is needed to
     identify the specific scan method intended.
    </para>

    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>

    <para>
<programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses);
</programlisting>

     Create a <structname>ForeignScan</structname> plan node from the selected foreign
     access path.  This is called at the end of query planning.
     The parameters are as for <function>GetForeignRelSize</function>, plus
     the selected <structname>ForeignPath</structname> (previously produced by
     <function>GetForeignPaths</function>), the target list to be emitted by the
     plan node, and the restriction clauses to be enforced by the plan node.
    </para>

    <para>
     This function must create and return a <structname>ForeignScan</structname> plan
     node; it's recommended to use <function>make_foreignscan</function> to build the
     <structname>ForeignScan</structname> node.
     </para>
 
     <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>

    <para>
<programlisting>
void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     Affiche une sortie <command>EXPLAIN</command> supplémentaire pour
     un parcours de table distante. Elle peut ne rien renvoyer si ce
     n'est pas nécessaire. Sinon, elle doit appeler
     <function>ExplainPropertyText</function> et les fonctions relatives
     pour ajouter des champs à la sortie du <command>EXPLAIN</command>.
     Les champs drapeaux dans <literal>es</literal> peuvent être utilisés
     pour déterminer ce qui doit être affiché et l'état du n&oelig;ud
     <structname>ForeignScanState</structname> peut être inspecté pour
     fournir des statistiques à l'exécution dans le cas d'un
     <command>EXPLAIN ANALYZE</command>.
    </para>

    <para>
<programlisting>
void
BeginForeignScan (ForeignScanState *node,
                  int eflags);
</programlisting>

     Commence l'exécution d'un parcours distant. L'appel se fait lors du
     démarrage de l'exécuteur. Cette fonction doit réaliser toutes les
     initialisation nécessaires avant le démarrage du parcours, mais ne
     doit pas commencer à exécuter le vrai parcours (cela se fera lors
     du premier appel à <function>IterateForeignScan</function>). Le
     n&oelig;ud <structname>ForeignScanState</structname> est déjà créé
     mais son champ <structfield>fdw_state</structfield> vaut toujours
     NULL. Les informations sur la table à parcourir sont accessibles
     via le n&oelig;ud <structname>ForeignScanState</structname> (en
     particulier à partir du n&oelig;ud sous-jacent
     <structname>ForeignScan</structname> qui contient toute information
     privée au FDW fournie par <function>GetForeignPlan</function>).
    </para>

    <para>
     Notez que quand <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>
     est vraie, cette fonction ne doit pas réaliser d'actions visibles
     en externe. Elle doit seulement faire le minimum requis pour que
     l'état du n&oelig;ud soit valide pour
     <function>ExplainForeignScan</function> et
     <function>EndForeignScan</function>.
    </para>

    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan (ForeignScanState *node);
</programlisting>

     Récupère une ligne de la source distante, la renvoyant dans un
     emplacement de ligne de table (le champ
     <structfield>ScanTupleSlot</structfield> du n&oelig;ud doit être
     utilisé dans ce but). Renvoie NULL s'il n'y a plus de lignes
     disponibles. L'infrastructure d'emplacement de ligne de table permet
     qu'une ligne physique ou virtuelle soit renvoyée. Dans la plupart
     des cas, la deuxième possibilité (virtuelle), est préférable d'un
     point de vue des performances. Notez que cette fonction est appelée
     dans un contexte mémoire dont la durée de vie est très courte et
     qui sera réinitialisé entre chaque appel. Créez un contexte mémoire
     dans <function>BeginForeignScan</function> si vous avez besoin d'un
     stockage qui tient plus longtemps ou utilisez le champ
     <structfield>es_query_cxt</structfield> de <structname>EState</structname>.
    </para>

    <para>
     Les lignes renvoyées doivent correspondre à la signature de la
     colonne de la table distante parcourue. Si vous préférez optimiser
     la récupération des colonnes inutiles, vous devez insérer des NULL
     dans les positions de ces colonnes
    </para>

    <para>
     Notez que l'exécuteur de <productname>PostgreSQL</productname> ne
     se préoccupe pas de savoir si les lignes renvoyées violent les
     contraintes <literal>NOT NULL</literal> définies sur les colonnes
     de la table distante. Le planificateur s'en préoccupe et pourrait
     mal optimiser les requêtes si des valeurs <literal>NULL</literal>
     sont présentes dans une colonne déclarée ne pas en contenir. Si une
     valeur <literal>NULL</literal> est découverte alors que l'utilisateur
     a déclaré qu'aucune valeur NULL ne devrait être présente, il pourrait
     être approprié de lever une erreur (exactement comme vous le feriez
     en cas d'un type de données inapproprié).
    </para>

    <para>
<programlisting>
void
ReScanForeignScan (ForeignScanState *node);
</programlisting>

     Recommence le parcours depuis le début. Notez que les paramètres
     dont dépent le parcours peuvent avoir changés de valeur, donc le
     nouveau parcours ne va pas forcément renvoyer les mêmes lignes.
    </para>

    <para>
<programlisting>
void
EndForeignScan (ForeignScanState *node);
</programlisting>

     Termine le parcours et relâche les ressources. Il n'est habituellement
     pas nécessaire de relâcher la mémoire allouée via palloc. Par contre,
     les fichiers ouverts et les connexions aux serveurs distants doivent
     être nettoyés.
    </para>

    <para>
<programlisting>
bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);
</programlisting>

     This function is called when <xref linkend="sql-analyze"/> is executed on
     a foreign table.  If the FDW can collect statistics for this
     foreign table, it should return <literal>true</literal>, and provide a pointer
     to a function that will collect sample rows from the table in
     <parameter>func</parameter>, plus the estimated size of the table in pages in
     <parameter>totalpages</parameter>.  Otherwise, return <literal>false</literal>.
     If the FDW does not support collecting statistics for any tables, the
     <function>AnalyzeForeignTable</function> pointer can be set to <literal>NULL</literal>.
    </para>

    <para>
     If provided, the sample collection function must have the signature
<programlisting>
int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);
</programlisting>

     A random sample of up to <parameter>targrows</parameter> rows should be collected
     from the table and stored into the caller-provided <parameter>rows</parameter>
     array.  The actual number of rows collected must be returned.  In
     addition, store estimates of the total numbers of live and dead rows in
     the table into the output parameters <parameter>totalrows</parameter> and
     <parameter>totaldeadrows</parameter>.  (Set <parameter>totaldeadrows</parameter> to zero
     if the FDW does not have any concept of dead rows.)
    </para>

    <para>
     The <structname>FdwRoutine</structname> struct type is declared in
     <filename>src/include/foreign/fdwapi.h</filename>, which see for additional
     details.
    </para>

   </sect1>

   <sect1 id="fdw-helpers">
    <title>Foreign Data Wrapper Helper Functions</title>

    <para>
     Several helper functions are exported from the core server so that
     authors of foreign data wrappers can get easy access to attributes of
     FDW-related objects, such as FDW options.
     To use any of these functions, you need to include the header file
     <filename>foreign/foreign.h</filename> in your source file.
     That header also defines the struct types that are returned by
     these functions.
    </para>

    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given OID.  A
     <structname>ForeignDataWrapper</structname> object contains properties
     of the FDW (see <filename>foreign/foreign.h</filename> for details).
    </para>

    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given OID.  A
     <structname>ForeignServer</structname> object contains properties
     of the server (see <filename>foreign/foreign.h</filename> for details).
    </para>

    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     This function returns a <structname>UserMapping</structname> object for
     the user mapping of the given role on the given server.  (If there is no
     mapping for the specific user, it will return the mapping for
     <literal>PUBLIC</literal>, or throw error if there is none.)  A
     <structname>UserMapping</structname> object contains properties of the
     user mapping (see <filename>foreign/foreign.h</filename> for details).
    </para>

    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     This function returns a <structname>ForeignTable</structname> object for
     the foreign table with the given OID.  A
     <structname>ForeignTable</structname> object contains properties of the
     foreign table (see <filename>foreign/foreign.h</filename> for details).
    </para>

    <para>
<programlisting>
List *
GetForeignTableColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     This function returns the per-column FDW options for the column with the
     given foreign table OID and attribute number, in the form of a list of
     <structname>DefElem</structname>.  NIL is returned if the column has no
     options.
    </para>

    <para>
     Some object types have name-based lookup functions in addition to the
     OID-based ones:
    </para>

    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given name.  If the wrapper
     is not found, return NULL if missing_ok is true, otherwise raise an
     error.
    </para>

    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given name.  If the server is not found,
     return NULL if missing_ok is true, otherwise raise an error.
     </para>
 
    </sect1>
 
   <sect1 id="fdw-planning">
    <title>Foreign Data Wrapper Query Planning</title>

    <para>
     The FDW callback functions <function>GetForeignRelSize</function>,
     <function>GetForeignPaths</function>, and <function>GetForeignPlan</function> must fit
     into the workings of the <productname>PostgreSQL</productname> planner.  Here are
     some notes about what they must do.
    </para>

    <para>
     The information in <literal>root</literal> and <literal>baserel</literal> can be used
     to reduce the amount of information that has to be fetched from the
     foreign table (and therefore reduce the cost).
     <literal>baserel-&gt;baserestrictinfo</literal> is particularly interesting, as
     it contains restriction quals (<literal>WHERE</literal> clauses) that should be
     used to filter the rows to be fetched.  (The FDW itself is not required
     to enforce these quals, as the core executor can check them instead.)
     <literal>baserel-&gt;reltargetlist</literal> can be used to determine which
     columns need to be fetched; but note that it only lists columns that
     have to be emitted by the <structname>ForeignScan</structname> plan node, not
     columns that are used in qual evaluation but not output by the query.
    </para>

    <para>
     Various private fields are available for the FDW planning functions to
     keep information in.  Generally, whatever you store in FDW private fields
     should be palloc'd, so that it will be reclaimed at the end of planning.
    </para>

    <para>
     <literal>baserel-&gt;fdw_private</literal> is a <type>void</type> pointer that is
     available for FDW planning functions to store information relevant to
     the particular foreign table.  The core planner does not touch it except
     to initialize it to NULL when the <literal>baserel</literal> node is created.
     It is useful for passing information forward from
     <function>GetForeignRelSize</function> to <function>GetForeignPaths</function> and/or
     <function>GetForeignPaths</function> to <function>GetForeignPlan</function>, thereby
     avoiding recalculation.
    </para>

    <para>
     <function>GetForeignPaths</function> can identify the meaning of different
     access paths by storing private information in the
     <structfield>fdw_private</structfield> field of <structname>ForeignPath</structname> nodes.
     <structfield>fdw_private</structfield> is declared as a <type>List</type> pointer, but
     could actually contain anything since the core planner does not touch
     it.  However, best practice is to use a representation that's dumpable
     by <function>nodeToString</function>, for use with debugging support available
     in the backend.
    </para>

    <para>
     <function>GetForeignPlan</function> can examine the <structfield>fdw_private</structfield>
     field of the selected <structname>ForeignPath</structname> node, and can generate
     <structfield>fdw_exprs</structfield> and <structfield>fdw_private</structfield> lists to be
     placed in the <structname>ForeignScan</structname> plan node, where they will be
     available at execution time.  Both of these lists must be
     represented in a form that <function>copyObject</function> knows how to copy.
     The <structfield>fdw_private</structfield> list has no other restrictions and is
     not interpreted by the core backend in any way.  The
     <structfield>fdw_exprs</structfield> list, if not NIL, is expected to contain
     expression trees that are intended to be executed at runtime.  These
     trees will undergo post-processing by the planner to make them fully
     executable.
    </para>

    <para>
     In <function>GetForeignPlan</function>, generally the passed-in targetlist can
     be copied into the plan node as-is.  The passed scan_clauses list
     contains the same clauses as <literal>baserel-&gt;baserestrictinfo</literal>,
     but may be re-ordered for better execution efficiency.  In simple cases
     the FDW can just strip <structname>RestrictInfo</structname> nodes from the
     scan_clauses list (using <function>extract_actual_clauses</function>) and put
     all the clauses into the plan node's qual list, which means that all the
     clauses will be checked by the executor at runtime.  More complex FDWs
     may be able to check some of the clauses internally, in which case those
     clauses can be removed from the plan node's qual list so that the
     executor doesn't waste time rechecking them.
    </para>

    <para>
     As an example, the FDW might identify some restriction clauses of the
     form <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>sub_expression</replaceable>, which it determines can be executed on
     the remote server given the locally-evaluated value of the
     <replaceable>sub_expression</replaceable>.  The actual identification of such a
     clause should happen during <function>GetForeignPaths</function>, since it would
     affect the cost estimate for the path.  The path's
     <structfield>fdw_private</structfield> field would probably include a pointer to
     the identified clause's <structname>RestrictInfo</structname> node.  Then
     <function>GetForeignPlan</function> would remove that clause from scan_clauses,
     but add the <replaceable>sub_expression</replaceable> to <structfield>fdw_exprs</structfield>
     to ensure that it gets massaged into executable form.  It would probably
     also put control information into the plan node's
     <structfield>fdw_private</structfield> field to tell the execution functions what
     to do at runtime.  The query transmitted to the remote server would
     involve something like <literal>WHERE <replaceable>foreign_variable</replaceable> =
     $1</literal>, with the parameter value obtained at runtime from
     evaluation of the <structfield>fdw_exprs</structfield> expression tree.
    </para>

    <para>
     The FDW should always construct at least one path that depends only on
     the table's restriction clauses.  In join queries, it might also choose
     to construct path(s) that depend on join clauses, for example
     <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>local_variable</replaceable>.  Such clauses will not be found in
     <literal>baserel-&gt;baserestrictinfo</literal> but must be sought in the
     relation's join lists.  A path using such a clause is called a
     <quote>parameterized path</quote>.  It must show the other relation(s) as
     <literal>required_outer</literal> and list the specific join clause(s) in
     <literal>param_clauses</literal>.  In <function>GetForeignPlan</function>, the
     <replaceable>local_variable</replaceable> portion of the join clause would be added
     to <structfield>fdw_exprs</structfield>, and then at runtime the case works the
     same as for an ordinary restriction clause.
    </para>

  </sect1>


 </chapter>
