<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="gist">
<title>Index GiST</title>

   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>

<sect1 id="gist-intro">
 <title>Introduction</title>

 <para>
   <acronym>GiST</acronym> est un acronyme de <foreignphrase>Generalized
   Search Tree</foreignphrase>, c'est-à-dire arbre de recherche généralisé.
   C'est une méthode d'accès balancée à structure de type arbre,
   qui agit comme un modèle de base dans lequel il est possible d'implanter
   des schémas d'indexage arbitraires. B-trees, R-trees et de nombreux autres
   schémas d'indexage peuvent être implantés en <acronym>GiST</acronym>.
 </para>

 <para>
  <acronym>GiST</acronym> a pour avantage d'autoriser le développement
  de types de données personnalisés avec les méthodes d'accès appropriées, par
  un expert en types de données, plutôt que par un expert en
  bases de données.
 </para>

  <para>
   Quelques informations disponibles ici sont dérivées du <ulink
   url="http://gist.cs.berkeley.edu/">site web</ulink> du projet d'indexage
   GiST de l'université de Californie à Berkeley et de la <ulink
    url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">thèse
   de Marcel Kornacker, 
   Méthodes d'accès pour les systèmes de bases de données de la prochaine
   génération</ulink>. L'implantation <acronym>GiST</acronym> de
   <productname>PostgreSQL</productname> est principalement maintenu
   par Teodor Sigaev et Oleg Bartunov. Leur <ulink
   url="http://www.sai.msu.su/~megera/postgres/gist/">site web</ulink> fournit
   de plus amples informations.
  </para>

</sect1>

<sect1 id="gist-extensibility">
 <title>Extensibilité</title>

 <para>
  L'implantation d'une nouvelle méthode d'accès à un index
  a toujours été un travail complexe. Il est, en effet, nécessaire de comprendre le
  fonctionnement interne de la base de données, tel que le gestionnaire de
  verrous ou le WAL.
 </para>
 
 <para>
  L'interface <acronym>GiST</acronym> dispose d'un haut niveau
  d'abstraction, ce qui autorise le codeur de la méthode d'accès à
  ne coder que la sémantique du type de données accédé. La
  couche <acronym>GiST</acronym> se charge elle-même de la gestion des accès concurrents,
  des traces et de la recherche dans la structure en arbre.
 </para>
 
 <para>
   Cette extensibilité n'est pas comparable à celle des
   autres arbres de recherche standard en termes de données gérées. Par
   exemple, <productname>PostgreSQL</productname> supporte les B-trees et les
   index de hachage extensibles. Cela signifie qu'il est possible d'utiliser
   <productname>PostgreSQL</productname> pour construire un B-tree ou un hachage
   sur tout type de données. Mais, les B-trees ne supportent
   que les prédicats d'échelle (<literal>&lt;</literal>,
   <literal>=</literal>, <literal>&gt;</literal>), les index de hachage
   que les requêtes d'égalité.
 </para>
 
 <para>
   Donc, lors de l'indexation d'une collection d'images, par exemple, avec un B-tree
   <productname>PostgreSQL</productname>, seules peuvent être lancées des requêtes de type  
   <quote>est-ce que imagex est égale à imagey</quote>,
   <quote>est-ce que imagex est plus petite que imagey</quote> et <quote>est-ce
   que imagex est plus grande que imagey</quote>. En fonction de la définition
   donnée à <quote>égale à</quote>, <quote>inférieure à</quote> ou
   <quote>supérieure à</quote>, cela peut avoir une utilité.
   Néanmoins, l'utilisation d'un index basé sur <acronym>GiST</acronym> permet
   de créer de nombreuses possibilités de poser des questions spécifiques au domaine,
   telles que <quote>trouver toutes les images de chevaux</quote> ou
   <quote>trouver toutes les images sur-exposées</quote>.
 </para>

 <para>
   Pour obtenir une méthode d'accès
   <acronym>GiST</acronym> fonctionnelle, il suffit de coder plusieurs méthodes
   utilisateur définissant le comportement des clés dans
   l'arbre. Ces méthodes doivent être suffisamment élaborées
   pour supporter des requêtes avancées, mais pour toutes les requêtes standard
   (B-trees, R-trees, etc.) elles sont relativement simples. En bref,
   <acronym>GiST</acronym> combine extensibilité, généralité, 
   ré-utilisation de code et interface claire.
  </para>

 <para>
   Une classe d'opérateur d'index <acronym>GiST</acronym> doit fournir sept
   méthodes, et une huitième optionnelle. La précision de l'index est assurée par l'implantation des
   méthodes <function>same</function>, <function>consistent</function>
   et <function>union</function> alors que l'efficacité (taille et rapidité)
   de l'index dépendra des méthodes <function>penalty</function> et
   <function>picksplit</function>. Les deux fonctions restantes sont
   <function>compress</function> et <function>decompress</function>, qui
   permettent à un index d'avoir des données internes de l'arbre d'un type
   différent de ceux des données qu'il indexe. Les feuilles doivent être du
   type des données indexées alors que les autres n&oelig;uds peuvent être de
   n'importe quelle structure C (mais vous devez toujours suivre les règles
   des types de données de <productname>PostgreSQL</productname> dans ce cas,
   voir ce qui concerne <literal>varlena</literal> pour les données de taille
   variable). Si le type de données interne de l'arbre existe au niveau SQL,
   l'option <literal>STORAGE</literal> de la commande <command>CREATE OPERATOR
   CLASS</command> peut être utilisée.
   La huitième méthode, optionnelle, est <function>distance</function>, qui
   est nécessaire si la classe d'opérateur souhaite supporter les parcours
   ordonnées (intéressant dans le cadre des recherches du voisin-le-plus-proche,
   <foreignphrase>nearest-neighbor</foreignphrase>).
 </para>

 <variablelist>
    <varlistentry>
     <term><function>consistent</function></term>
     <listitem>
      <para>
       Étant donné une entrée d'index <literal>p</literal> et une valeur de
       requête <literal>q</literal>, cette fonction détermine si l'entrée de
       l'index est cohérente (<quote>consistent</quote> en anglais) avec la
       requête&nbsp;; c'est-à-dire, est-ce que le prédicat
       <quote><replaceable>colonne_indexée</replaceable>
       <replaceable>opérateur_indexable</replaceable> <literal>q</literal></quote>
       soit vrai pour toute ligne représentée par l'entrée de l'index&nbsp;?
       Pour une entrée de l'index de type feuille, c'est l'équivalent pour
       tester la condition indexable, alors que pour un n&oelig;ud interne de
       l'arbre, ceci détermine s'il est nécessaire de parcourir le sous-arbre de
       l'index représenté par le n&oelig;ud. Quand le résultat est
       <literal>true</literal>, un drapeau <literal>recheck</literal> doit
       aussi être renvoyé. Ceci indique si le prédicat est vrai à coup sûr ou
       seulement peut-être vrai. Si <literal>recheck</literal> =
       <literal>false</literal>, alors l'index a testé exactement la condition
       du prédicat, alors que si <literal>recheck</literal>
       = <literal>true</literal>, la ligne est seulement un correspondance de
       candidat. Dans ce cas, le système évaluera automatiquement
       l'<replaceable>opérateur_indexable</replaceable> avec la valeur actuelle
       de la ligne pour voir s'il s'agit réellement d'une correspondance. Cette
       convention permet à <acronym>GiST</acronym> de supporter à la fois les
       structures sans pertes et celles avec perte de l'index.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_consistent(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
</programlisting>

       Ici, <varname>key</varname> est un élément dans l'index et
       <varname>query</varname> la valeur la recherchée dans l'index. Le
       paramètre <literal>StrategyNumber</literal> indique l'opérateur
       appliqué de votre classe d'opérateur. Il correspond à un des nombres
       d'opérateurs dans la commande <command>CREATE OPERATOR CLASS</command>.
       Suivant les opérateurs que vous avez inclus dans la classe, le type de
       données de <varname>query</varname> pourrait varier avec l'opérateur,
       mais le squelette ci-dessus suppose que ce n'est pas le cas.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>union</function></term>
     <listitem>
      <para>
       Cette méthode consolide l'information dans l'arbre. Suivant un ensemble
       d'entrées, cette fonction génère une nouvelle entrée d'index qui
       représente toutes les entrées données.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_union(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>

      <para>
        Comme vous pouvez le voir dans ce quelette, nous gérons un type de
	données où <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>.
	C'est assez simple pour supporter les types de données où ce n'est pas
	le cas, en implantant un autre algorithme d'union dans cette méthode
	de support <acronym>GiST</acronym>.
      </para>

      <para>
        La fonction d'implantation de <function>union</function> doit renvoyer
	un pointeur vers la mémoire qui vient d'être allouée via la fonction
        <function>palloc()</function>. Vous ne pouvez pas tout simplement
	renvoyer l'entrée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>compress</function></term>
     <listitem>
      <para>
       Convertit l'élément de données dans un format compatible avec
       le stockage physique dans une page d'index.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_compress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>

      <para>
       Vous devez adapter <replaceable>compressed_data_type</replaceable> au type
       spécifique que vous essayez d'obtenir pour compresser les n&oelig;uds
       finaux.
      </para>

      <para>
        Vous pourriez aussi avoir besoin de faire attention à la compression des
	valeurs <literal>NULL</literal>, en enregistrant par exemple
        <literal>(Datum) 0</literal> comme le fait <literal>gist_circle_compress</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decompress</function></term>
     <listitem>
      <para>
       L'inverse de la fonction <function>compress</function>. Convertit la
       représentation de l'élément de donnée en un format manipulable par la base
       de données.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_decompress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

        Le squelette ci-dessus est convenable dans le cas iù aucune
	décompression n'est nécessaire.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>penalty</function></term>
     <listitem>
      <para>
       Renvoie une valeur indiquant le <quote>coût</quote> d'insertion
       d'une nouvelle entrée dans une branche particulière de l'arbre. Les
       éléments seront insérés dans l'ordre des pénalités moindres
       (<function>penalty</function>) de l'arbre. Les valeurs renvoyées
       par <function>penalty</function> doivent être positives ou nulles.
       Si une valeur négative est renvoyée, elle sera traitée comme valant
       zéro.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_penalty(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>
      </para>

      <para>
        La fonction <function>penalty</function> est crucial pour de bonnes
	performances de l'index. Elle sera utilisée lors de l'insertion pour
	déterminer la branche à suivre pour savoir où ajoter la nouvelle entrée
	dans l'arbre. Lors de l'exécution de la requête, plus l'arbre sera bien
	balancé, plus l'exécution sera rapide.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</function></term>
     <listitem>
      <para>
       Quand une division de page est nécessaire pour un index, cette fonction
       décide des entrées de la page qui resteront sur l'ancienne page et de
       celles qui seront déplacées sur la nouvelle page.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_picksplit(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v_spl_left or
         * v_spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>
      </para>

      <para>
        Comme <function>penalty</function>, la fonction <function>picksplit</function>
	est cruciale pour de bonnes performances de l'index. Concevoir des
	implantations convenables des fonctions <function>penalty</function> et
	<function>picksplit</function> est le challenge d'un index
        <acronym>GiST</acronym> performant.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>same</function></term>
     <listitem>
      <para>
       Renvoit true si les deux entrées de l'index sont identiques, faux sinon.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction ressemble à
	ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_same(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut alors suivre ce
	squelette&nbsp;:

<programlisting>
Datum       my_same(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

        Pour des raisons historiques, la fonction <function>same</function> ne
	renvoie pas seulement un résultat booléen&nbsp;; à la place, il doit
	enregistrer le drapeau à l'emplacement indiqué par le troisième argument.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>distance</function></term>
     <listitem>
      <para>
       À partir d'une entrée d'index <literal>p</literal> et une valeur
       recherchée <literal>q</literal>, cette fonction détermine la
       <quote>distance</quote> entre l'entrée de l'index et la valeur
       recherchée. Cette fonction doit être fournie si la classe d'opérateur
       contient des opérateurs de tri. Une requête utilisant l'opérateur de
       tri sera implémentée en renvoyant les entrées d'index dont les valeurs
       de <quote>distance</quote> sont les plus petites, donc les résultats
       doivent être cohérents avec la sémantique de l'opérateur. Pour une
       entrée d'index de type feuille, le résultat représente seulement la
       distance vers l'entrée d'index. Pour un nœud de l'arbre interne, le
       résultat doit être la plus petite distance que toute entrée enfant
       représente.
      </para>

      <para>
        La déclaration <acronym>SQL</acronym> de la fonction doit ressembler
        à ceci&nbsp;:

<programlisting>
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        Et le code correspondant dans le module C peut correspondre à ce
        squelette&nbsp;:

<programlisting>
Datum       my_distance(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
</programlisting>

       Les arguments de la fonction <function>distance</function> sont
       identiques aux arguments de la fonction <function>consistent</function>,
       sauf qu'il n'y a pas de drapeau <quote>recheck</quote>. La distance vers
       une entrée d'index de type feuille doit toujours être déterminée
       exactement car il n'existe pas de moyen pour ré-ordonner les lignes
       une fois qu'elles ont été renvoyées. Une approximation est autorisée
       lors de la détermination de la distance vers un nœud de l'arbre interne,
       à partir du moment où le résultat n'est jamais plus grand que la
       distance réelle vers les enfants. Du coup, la distance vers une boîte
       englobante est habituellement suffisante dans les applications de
       géométrie. La valeur du résultat peut être une valeur
       <type>float8</type> finie. (l'infinité et sa valeur négative sont
       utilisée en interne pour gérer des cas comme les valeurs NULL, donc il
       n'est pas recommand que les fonctions <function>distance</function>
       renvoient ces valeurs.)
      </para>

     </listitem>
    </varlistentry>

  </variablelist>

  <para>
   All the GiST support methods are normally called in short-lived memory
   contexts; that is, <varname>CurrentMemoryContext</varname> will get reset after
   each tuple is processed.  It is therefore not very important to worry about
   pfree'ing everything you palloc.  However, in some cases it's useful for a
   support method to cache data across repeated calls.  To do that, allocate
   the longer-lived data in <literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</literal>, and
   keep a pointer to it in <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>.  Such
   data will survive for the life of the index operation (e.g., a single GiST
   index scan, index build, or index tuple insertion).  Be careful to pfree
   the previous value when replacing a <literal>fn_extra</literal> value, or the leak
   will accumulate for the duration of the operation.
  </para>

</sect1>

<sect1 id="gist-implementation">
 <title>Implementation</title>

 <sect2 id="gist-buffering-build">
  <title>GiST buffering build</title>
  <para>
   Building large GiST indexes by simply inserting all the tuples tends to be
   slow, because if the index tuples are scattered across the index and the
   index is large enough to not fit in cache, the insertions need to perform
   a lot of random I/O.  Beginning in version 9.2, PostgreSQL supports a more
   efficient method to build GiST indexes based on buffering, which can
   dramatically reduce the number of random I/Os needed for non-ordered data
   sets. For well-ordered datasets the benefit is smaller or non-existent,
   because only a small number of pages receive new tuples at a time, and
   those pages fit in cache even if the index as whole does not.
  </para>

  <para>
   However, buffering index build needs to call the <function>penalty</function>
   function more often, which consumes some extra CPU resources. Also, the
   buffers used in the buffering build need temporary disk space, up to
   the size of the resulting index. Buffering can also influence the quality
   of the resulting index, in both positive and negative directions. That
   influence depends on various factors, like the distribution of the input
   data and the operator class implementation.
  </para>

  <para>
   By default, a GiST index build switches to the buffering method when the
   index size reaches <xref linkend="guc-effective-cache-size"/>. It can
   be manually turned on or off by the <literal>BUFFERING</literal> parameter
   to the CREATE INDEX command. The default behavior is good for most cases,
   but turning buffering off might speed up the build somewhat if the input
   data is ordered.
  </para>

 </sect2>

</sect1>

<sect1 id="gist-examples">
 <title>Exemples</title>

 <para>
  La distribution source de <productname>PostgreSQL</productname> inclut
  plusieurs exemples de méthodes d'indexation implantées selon
  <acronym>GiST</acronym>. Le système principal fournit des fonctionnalités
  de recherche plein texte (indexation des <type>tsvector</type> et
  <type>tsquery</type>) ainsi que des fonctionnalités équivalentes aux R-Tree
  pour certains types de données géométriques
  (voir <filename>src/backend/access/gist/gistproc.c</filename>). Les modules
  <filename>contrib</filename> suivants contiennent aussi des classes d'opérateur
  <acronym>GiST</acronym>&nbsp;:
 </para>
 
 <variablelist>
  <varlistentry>
   <term><filename>btree_gist</filename></term>
   <listitem>
    <para>Fonctionnalités équivalentes aux B-Tree pour plusieurs types de
    données</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>cube</filename></term>
   <listitem>
    <para>Indexation de cubes multi-dimensionnels</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</filename></term>
   <listitem>
    <para>Module pour le stockage des paires (clé, valeur)</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</filename></term>
   <listitem>
    <para>RD-Tree pour tableaux uni-dimensionnels de valeurs int4</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>ltree</filename></term>
   <listitem>
    <para>Indexation des structures de type arbre</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</filename></term>
   <listitem>
    <para>Similarité textuelle par correspondance de trigrammes</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>seg</filename></term>
   <listitem>
    <para>Indexation pour les <quote>nombres
     flottants</quote></para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

</chapter>
