<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="monitoring">
 <title>Surveiller l'activité de la base de données</title>

 <indexterm zone="monitoring">
  <primary>surveiller</primary>
  <secondary>activité de la base de données</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>activité de la base de données</primary>
  <secondary>suveiller</secondary>
 </indexterm>

 <para>
  Un administrateur de bases de données se demande fréquemment&nbsp;: <quote>Que
  fait le système en ce moment&nbsp;?</quote> Ce chapitre discute de la façon
  de le savoir.
 </para>

  <para>
   Plusieurs outils sont disponibles pour surveiller l'activité de la base de
   données et pour analyser les performances. Une grande partie de ce chapitre
   concerne la description du récupérateur de statistiques de
   <productname>PostgreSQL</productname> mais personne ne devrait négliger les
   programmes de surveillance Unix standards tels que <command>ps</command>,
   <command>top</command>, <command>iostat</command> et <command>vmstat</command>. De plus, une fois
   qu'une requête peu performante a été identifiée, des investigations
   supplémentaires pourraient être nécessaires en utilisant la commande <xref
   linkend="sql-explain"/> de
   <productname>PostgreSQL</productname>. La <xref linkend="using-explain"/>
   discute de <command>EXPLAIN</command> et des autres méthodes pour comprendre le
   comportement d'une seule requête.
  </para>

 <sect1 id="monitoring-ps">
  <title>Outils Unix standard</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>pour surveiller l'activité</secondary>
  </indexterm>

  <para>
   Sur la plupart des plateformes Unix, <productname>PostgreSQL</productname> modifie
   son titre de commande reporté par <command>ps</command> de façon à ce que les
   processus serveur individuels puissent être rapidement identifiés. Voici un
   affichage d'exemple&nbsp;:

<screen>$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (L'appel approprié de <command>ps</command> varie suivant les différentes
   plateformes, de même que les détails affichés. Cet exemple est
   tiré d'un système Linux récent.) Le premier processus affiché ici est le
   processus serveur maître, le processus serveur maître. Les arguments
   affichés pour cette commande sont les mêmes qu'à son lancement. Les cinq
   processus suivant sont des processus en tâche de fond lancés
   automatiquement par le processus maître (le processus
   <quote>stats collector</quote> n'est pas présent si
   vous avez configuré le système pour qu'il ne lance pas le récupérateur de
   statistiques; likewise the <quote>autovacuum launcher</quote> process can
   be disabled.). Chacun des autres processus est un processus serveur gérant
   une connexion cliente. Tous ces processus restant initialisent l'affichage de
   la ligne de commande de la forme

<screen>postgres: <replaceable>utilisateur</replaceable> <replaceable>base_de_données</replaceable> <replaceable>hôte</replaceable> <replaceable>activité</replaceable></screen>

  L'utilisateur, la base de données et les éléments de l'hôte (client)
  restent identiques pendant toute la vie de connexion du client mais
  l'indicateur d'activité change. L'activité pourrait être <literal>idle</literal>
  (c'est-à-dire en attente d'une commande du client), <literal>idle in
  transaction</literal> (en attente du client à l'intérieur d'un bloc de
  <command>BEGIN</command>/<command>COMMIT</command>) ou un nom de commande du type
  <literal>SELECT</literal>. De plus, <literal>waiting</literal> est ajouté si le processus
  serveur est en attente d'un verrou détenu par une autre session.
  Dans l'exemple ci-dessus, nous pouvons supposer que le processus 15606 is
  waiting for process 15610 to complete its transaction
  and thereby release some lock.  (Process 15610 must be the blocker, because
  there is no other active session.  In more complicated cases it would be
  necessary to look into the
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  system view to determine who is blocking whom.)
  </para>

  <para>
   Si vous avez désactivé <xref linkend="guc-update-process-title"/>, alors
   l'indicateur d'activité n'est pas mis à jour&nbsp;; le titre du processus
   est configuré une seule fois quand un nouveau processus est lancé. Sur
   certaines plateformes, ceci permet d'économiser du temps. Sur d'autres,
   cette économie est insignifiante.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname> requiert une gestion particulière. Vous
  devez utiliser <command>/usr/ucb/ps</command> plutôt que
  <command>/bin/ps</command>. Vous devez aussi utiliser deux options
  <option>w</option> et non pas seulement une. En plus, votre appel original de
  la commande <command>postgres</command> doit avoir un affichage de statut
  dans <command>ps</command> plus petit que celui fourni par les autres
  processus serveur. Si vous échouez dans les trois, l'affichage de
  <command>ps</command> pour chaque processus serveur sera la ligne de commande
  originale de <command>postgres</command>.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>Le récupérateur de statistiques</title>

  <indexterm zone="monitoring-stats">
   <primary>statistiques</primary>
  </indexterm>

  <para>
   Le <firstterm>récupérateur de statistiques</firstterm> de
   <productname>PostgreSQL</productname> est un sous-système qui supporte la
   récupération et les rapports d'informations sur l'activité du serveur.
   Actuellement, le récupérateur peut compter les accès aux tables et index à la
   fois en terme de blocs disque et de lignes individuelles. Il conserve aussi
   la trace du nombre total de lignes dans chaque table ainsi que des informations
   sur les VACUUM et les ANALYZE pour chaque table.
   Il peut aussi compter le nombre d'appels aux fonctions définies par
   l'utilisateur ainsi que le temps total dépensé par chacune.
  </para>

  <para>
   <productname>PostgreSQL</productname> supporte aussi
   la détermination de la commande exacte en cours d'exécution par les autres
   processus serveur. Cette fonctionnalité indépendante ne dépend pas du
   récupérateur de statistiques.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>Configuration de la récupération de statistiques</title>

  <para>
   Comme la récupération de statistiques ajoute un temps supplémentaire à
   l'exécution de la requête, le système peut être configuré pour récupérer ou
   non des informations. Ceci est contrôlé par les paramètres de configuration
   qui sont normalement initialisés dans <filename>postgresql.conf</filename> (voir
   <xref linkend="runtime-config"/> pour plus de détails sur leur
   initialisation).
  </para>

  <para>
   The parameter <xref linkend="guc-track-activities"/> enables monitoring
   of the current command being executed by any server process.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-counts"/> contrôle si les statistiques
   sont récupérées pour les accès aux tables et index.
  </para>

  <para>
   Le paramètre <xref linkend="guc-track-functions"/> active le calcul de
   statistiques sur l'utilisation des fonctions définies par l'utilisateur.
  </para>

  <para>
   The parameter <xref linkend="guc-track-io-timing"/> enables monitoring
   of block read and write times.
  </para>

  <para>
   Normalement, ces paramètres sont configurés dans
   <filename>postgresql.conf</filename> de façon à ce qu'ils s'appliquent à tous les
   processus serveur mais il est possible de les activer/désactiver sur des
   sessions individuelles en utilisant la commande <xref
   linkend="sql-set"/> (pour empêcher les utilisateurs
   ordinaires de cacher leur activité à l'administrateur, seuls les
   superutilisateurs sont autorisés à modifier ces paramètres avec
   <command>SET</command>).
  </para>

  <para>
   The statistics collector transmits the collected information to other
   <productname>PostgreSQL</productname> processes through temporary files.
   These files are stored in the directory named by the
   <xref linkend="guc-stats-temp-directory"/> parameter,
   <filename>pg_stat_tmp</filename> by default.
   For better performance, <varname>stats_temp_directory</varname> can be
   pointed at a RAM-based file system, decreasing physical I/O requirements.
   When the server shuts down, a permanent copy of the statistics
   data is stored in the <filename>global</filename> subdirectory, so that
   statistics can be retained across server restarts.
  </para>

  <para>
   Une transaction peut aussi voir des statistiques propres à son
   activité (qui ne sont pas encore transmises au collecteur) dans les
   vues <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname> et
   <structname>pg_stat_xact_user_functions</structname>.
   Ces informations se mettent à jour
   en continue pendant l'exécution de la transaction.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>Visualiser les statistiques récupérées</title>

  <para>
   Plusieurs vues prédéfinies, listées dans le <xref
   linkend="monitoring-stats-views-table"/>, sont disponibles pour afficher
   les résultats de la récupération de statistiques. Autrement, vous pouvez
   construire des vues personnalisées en utilisant les fonctions statistiques
   existantes, as discussed
   in <xref linkend="monitoring-stats-functions"/>.
  </para>

  <para>
   En utilisant les statistiques pour surveiller l'activité en cours, il est
   important de réaliser que l'information n'est pas mise à jour instantanément.
   Chaque processus serveur individuel transmet les nouvelles statistiques au
   récupérateur juste avant l'attente d'une
   nouvelle commande du client&nbsp;; donc une requête toujours en cours
   n'affecte pas les totaux affichés. De plus, le récupérateur lui-même émet un
   nouveau rapport une fois par <varname>PGSTAT_STAT_INTERVAL</varname>
   millisecondes (500 millisecondes, sauf si cette valeur a été modifiée lors de la
   construction du serveur). Donc, les totaux affichés sont bien derrière
   l'activité réelle. Néanmoins, l'information sur la requête en cours récupérée
   par <varname>track_activities</varname> est toujours à jour.
  </para>

  <para>
   Un autre point important est que, lorsqu'un processus serveur se voit
   demander d'afficher une des statistiques, il récupère tout d'abord le rapport
   le plus récent émis par le processus de récupération, puis continue
   d'utiliser cette image de toutes les vues et fonctions statistiques jusqu'à
   la fin de sa transaction en cours. De façon similaire, les informations sur
   les requêtes en cours, quelque soit le processus, sont récupérées quand une
   telle information est demandée dans une transaction, et cette même information
   sera affichée lors de la transaction. Donc, les statistiques afficheront des
   informations statiques tant que vous restez dans la même transaction. Ceci est une
   fonctionnalité, et non pas un bogue, car il vous permet de traiter plusieurs
   requêtes sur les statistiques et de corréler les résultats sans vous
   inquiéter que les nombres aient pu changer. Mais si vous voulez voir les
   nouveaux résultats pour chaque requête, assurez-vous de lancer les requêtes
   en dehors de tout bloc de transaction. Autrement, vous pouvez appeler
   <function>pg_stat_clear_snapshot</function>(), qui annulera l'image statistique
   de la transaction en cours. L'utilisation suivante des informations
   statistiques causera la récupération d'une nouvelle image.
  </para>

  <table id="monitoring-stats-views-table">
   <title>Vues statistiques standards</title>

   <tgroup cols="2">
    <colspec colnum="1" colwidth="0.4*"/>
    <colspec colnum="2" colwidth="1.6*"/>
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       One row per server process, showing information related to
       the current activity of that process, such as state and current query.
       See <xref linkend="pg-stat-activity-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       background writer process's activity. See
       <xref linkend="pg-stat-bgwriter-view"/> for details.
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>One row per database, showing database-wide statistics. See
       <xref linkend="pg-stat-database-view"/> for details.
      </entry>
     </row>
     </tbody>

     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about accesses to that specific table.
       See <xref linkend="pg-stat-all-tables-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_tables</structname>, sauf que seules les
      tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_all_tables</structname>, mais
      décompte les actions prises dans la transaction en cours (qui ne
      sont <emphasis>pas</emphasis> encore pris en compte dans la vue
      <structname>pg_stat_all_tables</structname> et les vues du même
      type). Les colonnes correspondant au nombre de lignes vivantes et
      mortes, ainsi que celles pour les actions du VACUUM et de l'ANALYZE
      ne sont pas présentes dans cette vue.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>,
      sauf que seules les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_xact_all_tables</structname>,, sauf que seules les
      tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database, showing statistics
       about accesses to that specific index.
       See <xref linkend="pg-stat-all-indexes-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules les
      tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_stat_all_indexes</structname>, sauf que seules
      les tables utilisateurs sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about I/O on that specific table.
       See <xref linkend="pg-statio-all-tables-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables systèmes sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_tables</structname>, sauf que seules
      les tables utilisateur sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database,
       showing statistics about I/O on that specific index.
       See <xref linkend="pg-statio-all-indexes-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index systèmes sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_indexes</structname>, sauf que seuls
      les index utilisateur sont affichés.</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       One row for each sequence in the current database,
       showing statistics about I/O on that specific sequence.
       See <xref linkend="pg-statio-all-sequences-view"/> for details.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences système sont affichées (actuellement, aucune
      séquence système n'est définie, donc cette vue est toujours vide)</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Identique à <structname>pg_statio_all_sequences</structname>, sauf que
      seules les séquences utilisateur sont affichées.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       One row for each tracked function, showing statistics
       about executions of that function. See
       <xref linkend="pg-stat-user-functions-view"/> for details.
      </entry>
     </row>
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similaire à <structname>pg_stat_user_functions</structname>,
      mais compte seulement les appels pendant la transaction en cours
      (qui ne sont <emphasis>pas</emphasis> encore inclus dans
      <structname>pg_stat_user_functions</structname>).</entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>One row per WAL sender process, showing statistics about
       replication to that sender's connected standby server.
       See <xref linkend="pg-stat-replication-view"/> for details.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       One row per database, showing database-wide statistics about
       query cancels due to conflict with recovery on standby servers.
       See <xref linkend="pg-stat-database-conflicts-view"/> for details.
      </entry>
     </row>

    </tgroup>
   </table>
  </sect2>

  <para>
   Les statistiques par index sont particulièrement utiles pour déterminer
   les index utilisés et leur efficacité.
  </para>

  <para>
   Les vues <structname>pg_statio_</structname> sont principalement utiles pour
   déterminer l'efficacité du cache tampon. Quand le nombre de lectures disques
   réelles est plus petit que le nombre de récupérations valides par le tampon,
   alors le cache satisfait la plupart des demandes de lecture sans faire appel
   au noyau. Néanmoins, ces statistiques ne nous donnent pas l'histoire
   complète&nbsp;: à cause de la façon dont <productname>PostgreSQL</productname> gère les
   entrées/sorties disque, les données qui ne sont pas dans le tampon de
   <productname>PostgreSQL</productname> pourraient toujours résider dans le tampon
   d'entrées/sorties du noyau et pourraient, du coup, être toujours récupérées
   sans nécessiter une lecture physique. Les utilisateurs intéressés pour
   obtenir des informations plus détaillées sur le comportement des
   entrées/sorties dans <productname>PostgreSQL</productname> sont invités à utiliser le
   récupérateur de statistiques de <productname>PostgreSQL</productname> avec les outils du
   système d'exploitation permettant une vue de la gestion des
   entrées/sorties par le noyau.
  </para>

  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title>pg_stat_activity view</title>

   <tgroup cols="3">
    <colspec colnum="1" colwidth="2.0*"/>
    <colspec colnum="2" colwidth="0.3*"/>
    <colspec colnum="3" colwidth="1.2*"/>
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the database this backend is connected to</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the database this backend is connected to</entry>
    </row>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of this backend</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the user logged into this backend</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the user logged into this backend</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the application that is connected
      to this backend</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>IP address of the client connected to this backend.
      If this field is null, it indicates either that the client is
      connected via a Unix socket on the server machine or that this is an
      internal process such as autovacuum.
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</structfield>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"/> is enabled.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>TCP port number that the client is using for communication
      with this backend, or <literal>-1</literal> if a Unix socket is used
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process was started, i.e., when the
      client connected to the server
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process' current transaction was started, or null
      if no transaction is active. If the current
      query is the first of its transaction, this column is equal to the
      <structfield>query_start</structfield> column.
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when the currently active query was started, or if
      <structfield>state</structfield> is not <literal>active</literal>, when the last query
      was started
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when the <structfield>state</structfield> was last changed</entry>
    </row>
    <row>
     <entry><structfield>waiting</structfield></entry>
     <entry><type>boolean</type></entry>
     <entry>True if this backend is currently waiting on a lock</entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Current overall state of this backend.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</literal>: The backend is executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</literal>: The backend is waiting for a new client command.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</literal>: The backend is in a transaction,
           but is not currently executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</literal>: This state is similar to
           <literal>idle in transaction</literal>, except one of the statements in
           the transaction caused an error.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</literal>: The backend is executing a
           fast-path function.
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</literal>: This state is reported if <xref
           linkend="guc-track-activities"/> is disabled in this backend.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>query</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Text of this backend's most recent query. If
      <structfield>state</structfield> is <literal>active</literal> this field shows the
      currently executing query. In all other states, it shows the last query
      that was executed.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>

  <note>
   <para>
    The <structfield>waiting</structfield> and <structfield>state</structfield> columns are
    independent.  If a backend is in the <literal>active</literal> state,
    it may or may not be <literal>waiting</literal>.  If the state is
    <literal>active</literal> and <structfield>waiting</structfield> is true, it means
    that a query is being executed, but is being blocked by a lock
    somewhere in the system.
   </para>
  </note>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title><structname>pg_stat_bgwriter</structname> View</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of scheduled checkpoints that have been performed</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of requested checkpoints that have been performed</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are written to disk, in milliseconds
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are synchronized to disk, in
        milliseconds
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written during checkpoints</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written by the background writer</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of times the background writer stopped a cleaning
       scan because it had written too many buffers</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers written directly by a backend</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of times a backend had to execute its own
       <function>fsync</function> call (normally the background writer handles those
       even when the backend does its own write)</entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers allocated</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time at which these statistics were last reset</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   The <structname>pg_stat_bgwriter</structname> view will always have a
   single row, containing global data for the cluster.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title><structname>pg_stat_database</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a database</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this database</entry>
    </row>
    <row>
     <entry><structfield>numbackends</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Number of backends currently connected to this database.
     This is the only column in this view that returns a value reflecting
     current state; all other columns return the accumulated values since
     the last reset.</entry>
    </row>
    <row>
     <entry><structfield>xact_commit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of transactions in this database that have been
      committed</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of transactions in this database that have been
      rolled back</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read in this database</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times disk blocks were found already in the buffer
      cache, so that a read was not necessary (this only includes hits in the
      PostgreSQL buffer cache, not the operating system's file system cache)
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows returned by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows fetched by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows inserted by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows updated by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows deleted by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>conflicts</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries canceled due to conflicts with recovery
      in this database. (Conflicts occur only on standby servers; see
      <xref linkend="pg-stat-database-conflicts-view"/> for details.)
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of temporary files created by queries in this database.
      All temporary files are counted, regardless of why the temporary file
      was created (e.g., sorting or hashing), and regardless of the
      <xref linkend="guc-log-temp-files"/> setting.
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Total amount of data written to temporary files by queries in
      this database. All temporary files are counted, regardless of why
      the temporary file was created, and
      regardless of the <xref linkend="guc-log-temp-files"/> setting.
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of deadlocks detected in this database</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Time spent reading data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Time spent writing data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time at which these statistics were last reset</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, showing database-wide statistics.
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title><structname>pg_stat_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this table</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of sequential scans initiated on this table</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live rows fetched by sequential scans</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index scans initiated on this table</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live rows fetched by index scans</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows inserted</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows updated</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows deleted</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of rows HOT updated (i.e., with no separate index
      update required)</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Estimated number of live rows</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Estimated number of dead rows</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was manually vacuumed
      (not counting <command>VACUUM FULL</command>)</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was vacuumed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was manually analyzed</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Last time at which this table was analyzed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been manually vacuumed
      (not counting <command>VACUUM FULL</command>)</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been vacuumed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been manually analyzed</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this table has been analyzed by the autovacuum
      daemon</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title><structname>pg_stat_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of this index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this index</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index scans initiated on this index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of index entries returned by scans on this index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of live table rows fetched by simple index scans using this
      index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>

  <para>
   Indexes can be used via either simple index scans or <quote>bitmap</quote>
   index scans.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
  </para>

  <note>
   <para>
    The <structfield>idx_tup_read</structfield> and <structfield>idx_tup_fetch</structfield> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</structfield> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</structfield>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title><structname>pg_statio_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from all indexes on this table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in all indexes on this table</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table's TOAST table (if any)</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table's TOAST table (if any)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this table's TOAST table index (if any)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this table's TOAST table index (if any)</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title><structname>pg_statio_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of this index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title><structname>pg_statio_all_sequences</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a sequence</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this sequence is in</entry>
    </row>
    <row>
     <entry><structfield>relname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this sequence</entry>
    </row>
    <row>
     <entry><structfield>blks_read</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of disk blocks read from this sequence</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of buffer hits in this sequence</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title><structname>pg_stat_user_functions</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a function</entry>
    </row>
    <row>
     <entry><structfield>schemaname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the schema this function is in</entry>
    </row>
    <row>
     <entry><structfield>funcname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this function</entry>
    </row>
    <row>
     <entry><structfield>calls</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of times this function has been called</entry>
    </row>
    <row>
     <entry><structfield>total_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Total time spent in this function and all other functions
     called by it, in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>self_time</structfield></entry>
     <entry><type>double precision</type></entry>
     <entry>Total time spent in this function itself, not including
     other functions called by it, in milliseconds</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"/> parameter
   controls exactly which functions are tracked.
  </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title><structname>pg_stat_replication</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Process ID of a WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>usesysid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of the user logged into this WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>usename</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of the user logged into this WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>application_name</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Name of the application that is connected
      to this WAL sender</entry>
    </row>
    <row>
     <entry><structfield>client_addr</structfield></entry>
     <entry><type>inet</type></entry>
     <entry>IP address of the client connected to this WAL sender.
      If this field is null, it indicates that the client is
      connected via a Unix socket on the server machine.
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</structfield>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"/> is enabled.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>TCP port number that the client is using for communication
      with this WAL sender, or <literal>-1</literal> if a Unix socket is used
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</structfield></entry>
     <entry><type>timestamp with time zone</type></entry>
     <entry>Time when this process was started, i.e., when the
      client connected to this WAL sender
     </entry>
    </row>
    <row>
     <entry><structfield>state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Current WAL sender state</entry>
    </row>
    <row>
     <entry><structfield>sent_location</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Last transaction log position sent on this connection</entry>
    </row>
    <row>
     <entry><structfield>write_location</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Last transaction log position written to disk by this standby
      server</entry>
    </row>
    <row>
     <entry><structfield>flush_location</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Last transaction log position flushed to disk by this standby
      server</entry>
    </row>
    <row>
     <entry><structfield>replay_location</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Last transaction log position replayed into the database on this
      standby server</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</structfield></entry>
     <entry><type>integer</type></entry>
     <entry>Priority of this standby server for being chosen as the
      synchronous standby</entry>
    </row>
    <row>
     <entry><structfield>sync_state</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Synchronous state of this standby server</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <title><structname>pg_stat_database_conflicts</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</structfield></entry>
     <entry><type>oid</type></entry>
     <entry>OID of a database</entry>
    </row>
    <row>
     <entry><structfield>datname</structfield></entry>
     <entry><type>name</type></entry>
     <entry>Name of this database</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      dropped tablespaces</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      lock timeouts</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      old snapshots</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      pinned buffers</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</structfield></entry>
     <entry><type>bigint</type></entry>
     <entry>Number of queries in this database that have been canceled due to
      deadlocks</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on master servers.
  </para>

 </sect1>

 <sect2 id="monitoring-stats-functions">
  <title>Statistics Functions</title>

  <para>
   Other ways of looking at the statistics can be set up by writing
   queries that use the same underlying statistics access functions used by
   the standard views shown above.  For details such as the functions' names,
   consult the definitions of the standard views.  (For example, in
   <application>psql</application> you could issue <literal>\d+ pg_stat_activity</literal>.)
   The access functions for per-database statistics take a database OID as an
   argument to identify which database to report on.
   The per-table and per-index functions take a table or index OID.
   The functions for per-function statistics take a function OID.
   Note that only tables, indexes, and functions in the current database
   can be seen with these functions.
  </para>

  <para>
   Additional functions related to statistics collection are listed in <xref
   linkend="monitoring-stats-funcs-table"/>.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>Additional Statistics Functions</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Process ID of the server process handling the current session
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Returns a record of information about the backend with the specified PID, or
       one record for each active backend in the system if <symbol>NULL</symbol> is
       specified. The fields returned are a subset of those in the
       <structname>pg_stat_activity</structname> view.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Discard the current statistics snapshot
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset all statistics counters for the current database to zero
       (requires superuser privileges)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset some cluster-wide statistics counters to zero, depending on the
       argument (requires superuser privileges).
       Calling <literal>pg_stat_reset_shared('bgwriter')</literal> will zero all the
       counters shown in the <structname>pg_stat_bgwriter</structname> view.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single table or index in the current database to
       zero (requires superuser privileges)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single function in the current database to
       zero (requires superuser privileges)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <function>pg_stat_get_activity</function>, the underlying function of
   the <structname>pg_stat_activity</structname> view, returns a set of records
   containing all the available information about each backend process.
   Sometimes it may be more convenient to obtain just a subset of this
   information.  In such cases, an older set of per-backend statistics
   access functions can be used; these are shown in <xref
   linkend="monitoring-stats-backend-funcs-table"/>.
   These access functions use a backend ID number, which ranges from one
   to the number of currently active backends.
   The function <function>pg_stat_get_backend_idset</function> provides a
   convenient way to generate one row for each active backend for
   invoking these functions.  For example, to show the <acronym>PID</acronym>s and
   current queries of all backends:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <title>Per-Backend Statistics Functions</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>Set of currently active backend ID numbers (from 1 to the
       number of active backends)</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>Text of this backend's most recent query</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the most recent query was started</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>IP address of the client connected to this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>TCP port number that the client is using for communication</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the database this backend is connected to</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>Process ID of this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when this process was started</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the user logged into this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting(integer)</function></literal></entry>
      <entry><type>boolean</type></entry>
      <entry>True if this backend is currently waiting on a lock</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the current transaction was started</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </chapter>

 <sect1 id="monitoring-locks">
  <title>Visualiser les verrous</title>

  <indexterm zone="monitoring-locks">
   <primary>verrou</primary>
   <secondary>surveillance</secondary>
  </indexterm>

  <para>
   Un autre outil utile pour surveiller l'activité des bases de données est la
   table système <structname>pg_locks</structname>. Elle permet à
   l'administrateur système de visualiser des informations sur les verrous
   restant dans le gestionnaire des verrous. Par exemple, cette fonctionnalité
   peut être utilisée pour&nbsp;:
	
   <itemizedlist>
    <listitem>
     <para>
      Visualiser tous les verrous en cours, tous les verrous sur les relations
      d'une base de données particulière ou tous les verrous détenus par une
      session <productname>PostgreSQL</productname> particulière.
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer la relation de la base de données disposant de la plupart des
      verrous non autorisés (et qui, du coup, pourraient être une source de
      contention parmi les clients de la base de données).
     </para>
    </listitem>

    <listitem>
     <para>
      Déterminer l'effet de la contention des verrous sur les performances
      générales des bases de données, ainsi que l'échelle dans laquelle varie la
      contention sur le trafic de la base de données.
     </para>
    </listitem>
   </itemizedlist>

   Les détails sur la vue <structname>pg_locks</structname> apparaissent dans la
   <xref linkend="view-pg-locks"/>. Pour plus d'informations sur les verrous et
   la gestion des concurrences avec <productname>PostgreSQL</productname>,
   référez-vous au <xref linkend="mvcc"/>.
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <title>Traces dynamiques</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname> fournit un support pour les traces
   dynamiques du serveur de bases de données. Ceci permet l'appel à un outil
   externe à certains points du code pour tracer son exécution.
  </para>

  <para>
   Un certain nombre de sondes et de points de traçage sont déjà insérés dans
   le code source. Ces sondes ont pour but d'être utilisées par des développeurs
   et des administrateurs de base de données. Par défaut, les sondes ne sont pas
   compilées dans <productname>PostgreSQL</productname>&nbsp;; l'utilisateur a
   besoin de préciser explicitement au script configure de rendre disponible
   les sondes.
  </para>

  <para>
   Actuellement, seul l'outil <ulink
   url="http://opensolaris.org/os/community/dtrace/">DTrace</ulink>, disponible
   sur OpenSolaris, Solaris 10 et Mac OS X Leopard, est supporté. DTrace devrait
   être disponible pour FreeBSD dans le futur et peut-être pour d'autres systèmes
   d'exploitation.Le projet <ulink
   url="http://sourceware.org/systemtap/">SystemTap</ulink> pour Linux fournit
   aussi un équivalent DTrace. Le support d'autres outils de traces dynamiques
   est possible théoriquement en modifiant les définitions des macros dans
   <filename>src/include/utils/probes.h</filename>.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Compiler en activant les traces dynamiques</title>

  <para>
   Par défaut, les sondes ne sont pas disponibles, donc vous aurez besoin d'indiquer
   explicitement au script configure de les activer dans
   <productname>PostgreSQL</productname>. Pour inclure le support de DTrace,
   ajoutez <option>--enable-dtrace</option> aux options de configure. Lire
   <xref linkend="install-procedure"/> pour plus d'informations.
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Sondes disponibles</title>

  <para>
   Un certain nombre de sondes standards sont fournies dans le code source,
   comme indiqué dans <xref linkend="dtrace-probe-point-table"/>. <xref
   linkend="typedefs-table"/> précise les types utilisés dans les sondes.
   D'autres peuvent être ajoutées pour améliorer la surveillance de
   <productname>PostgreSQL</productname>.
  </para>

 <table id="dtrace-probe-point-table">
  <title>Sondes disponibles pour DTrace</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Nom</entry>
     <entry>Paramètres</entry>
     <entry>Aperçu</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Sonde qui se déclenche au lancement d'une nouvelle transaction.
      arg0 est l'identifiant de transaction.</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Sonde qui se déclenche quand une transaction se termine avec succès.
      arg0 est l'identifiant de transaction.</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Sonde qui se déclenche quand une transaction échoue.
      arg0 est l'identifiant de transaction.</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque le traitement d'une requête commence.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque le traitement d'une requête se termine.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque l'analyse d'une requête commence.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque l'analyse d'une requête se termine.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête commence.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche lorsque la ré-écriture d'une requête se termine.
      arg0 est la requête.</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche lorsque la planification d'une requête commence.</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche lorsque la planification d'une requête se termine.</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche lorsque l'exécution d'une requête commence.</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche lorsque l'exécution d'une requête se termine.</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <entry>Sonde qui se déclenche à chaque fois que le processus serveur met à
      jour son statut dans
      <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
      arg0 est la nouvelle chaîne de statut.</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Sonde qui se déclenche quand un point de retournement commence son
      exécution.
      arg0 détient les drapeaux bit à bit utilisés pour distingurer les
      différents types de points de retournement, comme un point suite à un
      arrêt, un point immédiat ou un point forcé.</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <entry>Sonde qui se déclenche quand un point de retournement a terminé son
      exécution (les sondes listées après se déclenchent en séquence lors du
      traitement d'un point de retournement).
      arg0 est le nombre de tampons mémoires écrits. arg1 est le nombre total
      de tampons mémoires. arg2, arg3 et arg4 contiennent respectivement le
      nombre de journaux de transactions ajoutés, supprimés et recyclés.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
      retournement commence.
      arg0 est true pour un point de retournement normal, false pour un point
      de retournement suite à un arrêt.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion CLOG d'un point de
      retournement commence.
      arg0 a la même signification que pour clog-checkpoint-start.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
      retournement commence.
      arg0 est true pour un point de retournement normal, false pour un point
      de retournement suite à un arrêt.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion SUBTRANS d'un point de
      retournement se termine.
      arg0 a la même signification que pour subtrans-checkpoint-start.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
      retournement commence.
      arg0 est true pour un point de retournement normal, false pour un point
      de retournement suite à un arrêt.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Sonde qui se déclenche quand la portion MultiXact d'un point de
      retournement se termine.
      arg0 a la même signification que pour multixact-checkpoint-start.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Sonde qui se déclenche quand la portion d'écriture de tampons d'un
      point de retournement commence.
      arg0 contient les drapeaux bit à bit pour distinguer différents types de
      point de retournement comme le point après arrêt, un point immédiat, un
      point forcé.</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <entry>Sonde qui se déclenche quand nous commençons d'écrire les tampons
      modifiés pendant un point de retournement (après identification des
      tampons qui doivent être écrits).
      arg0 est le nombre total de tampons.
      arg1 est le nombre de tampons qui sont modifiés et n'ont pas besoin
      d'être écrits.</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <entry>Sonde qui se déclenche après chaque écriture d'un tampon lors d'un
      point de retournement.
      arg0 est le numéro d'identifiant du tampon.</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <entry>Sonde qui se déclenche quand tous les tampons modifiés ont été
      écrits.
      arg0 est le nombre total de tampons.
      arg1 est le nombre de tampons réellement écrits par le processus de point
      de retournement.
      arg2 est le nombre attendu de tampons à écrire (arg1 de
      buffer-sync-start)&nbsp;; toute différence reflète d'autres processus
      écrivant des tampons lors du point de retournement.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche une fois les tampons modifiés écrits par le
      noyau et avant de commencer à lancer des requêtes fsync.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche après la fin de la synchronisation des
     tampons sur le disque.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
      retournement est commencée.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand la portion deux-phases d'un point de
      retournement est terminée.</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</entry>
     <entry>Sonde qui se déclenche quand la lecture d'un tampon commence.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
      vaudra -1 s'il s'agit de demande d'extension de la relation).
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.
      arg6 est true pour une demande d'extension de la relation, false pour
      une lecture ordinaire.</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</entry>
     <entry>Sonde qui se déclenche quand la lecture d'un tampon se termine.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page (arg1
      contient le numéro de bloc du nouveau bloc ajouté s'il s'agit de demande
      d'extension de la relation).
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.
      arg6 est true pour une demande d'extension de la relation, false pour
      une lecture ordinaire.
      arg7 est true si la tampon était disponible en mémoire, false sinon.</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Sonde qui se déclenche avant de lancer une demande d'écriture pour
      un bloc partagé.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Sonde qui se déclenche quand une demande d'écriture se termine.
      (Notez que ceci ne reflète que le temps passé pour fournir la donnée au
      noyau&nbsp;; ce n'est habituellement pas encore écrit sur le disque.)
      Les arguments sont identiques à ceux de buffer-flush-start.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
      un tampon modifié sur disque. Si cela arrive souvent, cela implique que
      <xref linkend="guc-shared-buffers"/> est trop petit ou que les paramètres
      de contrôle de bgwriter ont besoin d'un ajustement.)
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié est
      terminé.
      Les arguments sont identiques à ceux de buffer-write-dirty-start.</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand un processus serveur commence à écrire
      un tampon modifié d'un journal de transactions parce qu'il n'y a plus
      d'espace disponible dans le cache des journaux de transactions. (Si cela
      arrive souvent, cela implique que <xref linkend="guc-wal-buffers"/> est
      trop petit.)</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand l'écriture d'un tampon modifié d'un
      journal de transactions est terminé.</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <entry>Sonde qui se déclenche quand un enregistrement est inséré dans un
      journal de transactions.
      arg0 est le gestionnaire de ressource (rmid) pour l'enregistrement.
      arg1 contient des informations supplémentaires.</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand une bascule du journal de transactions
      est demandée.</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>Sonde qui se déclenche au début de la lecture d'un bloc d'une
     relation.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>Sonde qui se déclenche à la fin de la lecture d'un bloc.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.
      arg6 est le nombre d'octets réellement lus alors que arg7 est le nombre
      d'octets demandés (s'il y a une différence, il y a un problème).</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>Sonde qui se déclenche au début de l'écriture d'un bloc dans une
      relation.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>Sonde qui se déclenche à la fin de l'écriture d'un bloc.
      arg0 et arg1 contiennent les numéros de fork et de bloc de la page.
      arg2, arg3 et arg4 contiennent respectivement l'OID du tablespace, de la
      base de données et de la relation identifiant ainsi précisément la
      relation.
      arg5 est l'identifiant du processus moteur qui a créé la relation
      temporaire pour un tampon local ou InvalidBackendId (-1) pour un
      tampon partagé.
      arg6 est le nombre d'octets réellement écrits alors que arg7 est le nombre
      d'octets demandés (si ces nombres sont différents, cela indique un
      problème).</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <entry>Sonde qui se déclenche quand une opération de tri est démarré.
      arg0 indique un tri de la table, de l'index ou d'un datum.
      arg1 est true si on force les valeurs uniques.
      arg2 est le nombre de colonnes clés.
      arg3 est le nombre de Ko de mémoire autorisé pour ce travail.
      arg4 est true si un accès aléatoire au résultat du tri est requis.</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <entry>Sonde qui se déclenche quand un tri est terminé.
      arg0 est true pour un tri externe, false pour un tri interne.
      arg1 est le nombre de blocs disque utilisés pour un tri externe, ou le
      nombre de Ko de mémoire utilisés pour un tri interne.</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Sonde qui se déclenche quand un LWLock a été acquis.
      arg0 est l'identifiant du LWLock.
      arg1 est le mode de verrou demandé, soit exclusif soit partagé.</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(LWLockId)</entry>
     <entry>Sonde qui se déclenche quand un LWLock a été relâché (mais notez
      que tout processus en attente n'a pas encore été réveillé).
      arg0 est l'identifiant du LWLock.</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Sonde qui se déclenche quand un LWLock n'était pas immédiatement
      disponible et qu'un processus serveur a commencé à attendre la
      disponibilité du verrou.
      arg0 est l'identifiant du LWLock.
      arg1 est le mode de verrou demandé, soit exclusif soit partagé.</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Sonde qui se déclenche quand un processus serveur n'est plus en
      attente d'un LWLock (il n'a pas encore le verrou).
      arg0 est l'identifiant du LWLock.
      arg1 est le mode de verrou demandé, soit exclusif soit partagé.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Sonde qui se déclenche quand un LWLock a été acquis avec succès
      malgré le fait que l'appelant ait demandé de ne pas attendre.
      arg0 est l'identifiant du LWLock.
      arg1 est le mode de verrou demandé, soit exclusif soit partagé.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Sonde qui se déclenche quand un LWLock, demandé sans attente, n'est
      pas accepté.
      arg0 est l'identifiant du LWLock.
      arg1 est le mode de verrou demandé, soit exclusif soit partagé.</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Sonde qui se déclenche quand une demande d'un gros verrou
      (<foreignphrase>lmgr lock</foreignphrase>) a commencé l'attente parce que
      le verrou n'était pas disponible.
      arg0 à arg3 sont les chmps identifiant l'objet en cours de verrouillage.
      arg4 indique le type d'objet à verrouiller.
      arg5 indique le type du verrou demandé.</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Sonde qui se déclenche quand une demande d'un gros verrou
      (<foreignphrase>lmgr lock</foreignphrase>) a fini d'attendre (c'est-à-dire
      que le verrou a été accepté).
      Les arguments sont identiques à ceux de lock-wait-start.</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <entry>Sonde qui se déclenche quand un verrou mortel est trouvé par le
      détecteur.</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>Types définis utilisés comme paramètres de sonde</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>LWLockId</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>
  </sect2>

  <sect2 id="using-trace-points">
   <title>Utiliser les sondes</title>

  <para>
   L'exemple ci-dessous montre un script DTrace pour l'analyse du nombre de
   transactions sur le système, comme alternative à l'interrogation régulière
   de <structname>pg_stat_database</structname> avant et après un test de
   performance&nbsp;:
<programlisting>#!/usr/sbin/dtrace -qs 

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   À son exécution, le script de l'exemple D donne une sortie comme&nbsp;:
<screen># ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <para>
    SystemTap utilise une notation différente de DTrace pour les scripts de
    trace, même si les points de trace sont compatibles. Il est intéressant de
    noter que, lorsque nous avons écrit ce texte, les scripts SystemTap doivent
    référencer les noms des sondes en utilisant des tirets bas doubles à la
    place des tirets simples. Il est prévu que les prochaines versions de
    SystemTap corrigent ce problème.
   </para>
  </note>

  <para>
   Vous devez vous rappeler que les programmes DTrace doivent être écrits
   soigneusement, sinon les informations récoltées pourraient ne rien valoir.
   Dans la plupart des cas où des problèmes sont découverts, c'est
   l'instrumentation qui est erronée, pas le système sous-jacent. En discutant
   des informations récupérées en utilisant un tel système, il est essentiel de
   s'assurer que le script utilisé est lui-aussi vérifié et discuter.
  </para>
  <para>
   D'autres exemples de scripts sont disponibles dans le <ulink
   url="http://pgfoundry.org/projects/dtrace/">projet dtrace</ulink> de PgFoundry.
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Définir de nouvelles sondes</title>

  <para>
   De nouvelles sondes peuvent être définies dans le code partout où le
   développeur le souhaite bien que cela nécessite une nouvelle compilation.
   Voici les étapes nécessaires pour insérer de nouvelles sondes&nbsp;:
  </para>

  <procedure>
   <step>
    <para>
     Décider du nom de la sonde et des données nécessaires pour la sonde
    </para>
   </step>

   <step>
    <para>
     Ajoutez les définitions de sonde dans
     <filename>src/backend/utils/probes.d</filename>
    </para>
   </step>

   <step>
    <para>
     Inclure <filename>pg_trace.h</filename> s'il n'est pas déjà présent dans le
     module contenant les points de sonde, et insérer les macros
     <literal>TRACE_POSTGRESQL</literal> aux emplacements souhaités dans le code
     source
    </para>
   </step>

   <step>
    <para>
     Recompiler et vérifier que les nouvelles sondes sont disponibles
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>Exemple&nbsp;:</title>
   <para>
    Voici un exemple d'ajout d'une sonde pour tracer toutes les nouvelles
    transactions par identifiant de transaction.
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     La sonde sera nommée <literal>transaction-start</literal> et nécessite
     un paramètre de type LocalTransactionId
    </para>
   </step>

   <step>
    <para>
     Ajout de la définition de la sonde dans
     <filename>src/backend/utils/probes.d</filename>&nbsp;:
<programlisting>
      probe transaction__start(LocalTransactionId);
</programlisting>
     Notez l'utilisation du double tiret bas dans le nom de la sonde. Dans un
     script DTrace utilisant la sonde, le double tiret bas doit être remplacé
     par un tiret, donc <literal>transaction-start</literal> est le nom à
     documenter pour les utilisateurs.
    </para>
   </step>

   <step>
    <para>
     Au moment de la compilation, <literal>transaction__start</literal> est
     converti en une macro appelée <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>
     (notez que les tirets bas ne sont plus doubles ici), qui est disponible
     en incluant le fichier <filename>pg_trace.h</filename>. Il faut ajouter
     l'appel à la macro aux bons emplacements dans le code source. Dans ce
     cas, cela ressemble à&nbsp;:

<programlisting>
    TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Après une nouvelle compilation et l'exécution du nouveau binaire, il
     faut vérifier que la nouvelle sonde est disponible en exécutant la
     commande DTrace suivante. Vous deviez avoir cette sortie&nbsp;:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   Il faut faire attention à d'autres choses lors de l'ajout de macros de
   trace dans le code C&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Vous devez faire attention au fait que les types de données indiqués
      pour les paramètres d'une sonde correspondent aux types de données des
      variables utilisées dans la macro. Dans le cas contraire, vous obtiendrez
      des erreurs de compilation.
     </para>
    </listitem>


    <listitem>
     <para>
      Sur la plupart des platformes, si <productname>PostgreSQL</productname>
      est construit avec <option>--enable-dtrace</option>, les arguments pour
      une macro de trace seront évalués à chaque fois que le contrôle passe
      dans la macro, <emphasis>même si aucun traçage n'est réellement en
      cours</emphasis>. Cela a généralement peu d'importance si vous rapportez
      seulement les valeurs de quelques variables locales mais faites bien
      attention à l'utilisation de fonctions coûteuses. Si vous devez le faire,
      pensez à protéger la macro avec une vérification pour vous assurer que
      la trace est bien activée&nbsp;:

<programlisting>
    if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
        TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Chaque macro de trace a une macro <literal>ENABLED</literal>
      correspondante.
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

</sect1>
