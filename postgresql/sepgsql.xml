<!-- doc/src/sgml/sepgsql.sgml -->

<sect1 id="sepgsql" xreflabel="sepgsql">
 <title>sepgsql</title>

 <indexterm zone="sepgsql">
  <primary>sepgsql</primary>
 </indexterm>

 <para>
  <filename>sepgsql</filename> est un module chargeable ajoutant le
  support des contrôles d'accès par label basé sur la politique de
  sécurité de <productname>SELinux</productname>.
 </para>

 <warning>
   <para>
     L'implémentation actuelle a des limitations importantes et ne force pas
     le contrôle d'accès pour toutes les actions. Voir
     <xref linkend="sepgsql-limitations"/>.
   </para>
 </warning>

 <sect2 id="sepgsql-overview">
  <title>Aperçu</title>

  <para>
   Ce module s'intègre avec <productname>SELinux</productname> pour
   fournir une couche de vérification de sécurité supplémentaire qui va
   au-delà de ce qui est déjà fournit par
   <productname>PostgreSQL</productname>. De la perspective de
   <productname>SELinux</productname>, ce module permet à
   <productname>PostgreSQL</productname> de fonctionner comme un
   gestionnaire d'objet en espace utilisateur. Chaque accès à une table
   ou à une fonction initié par une requête DML sera vérifié par rapport
   à la politique de sécurité du système. Cette vérification est en plus
   des vérifications de droits SQL habituels effectuées par
   <productname>PostgreSQL</productname>.
  </para>

  <para>
   Les décisions de contrôle d'accès de <productname>SELinux</productname>
   sont faites en utilisant les labels de sécurité qui sont représentés
   par des chaînes comme
   <literal>system_u:object_r:sepgsql_table_t:s0</literal>. Chaque
   décision de contrôle d'accès implique deux labels&nbsp;: celui de
   l'utilisateur tentant de réaliser l'action et celui de l'objet sur
   lequel l'action est réalisée. Comme ces labels peuvent être appliqués
   sur tout type d'objet, les décisions de contrôle d'accès pour les
   objets stockés dans la base peuvent être (et avec ce module, sont)
   sujets au même critère général utilisé pour les objets de tout type
   (par exemple les fichiers). Ce concept a pour but de permettre la mise
   en place d'une politique centralisée pour protéger l'information
   quelque soit la façon dont l'information est stockée.
  </para>

  <para>
   L'instruction <xref linkend="sql-security-label"/> permet d'affecter
   un label de sécurité à un objet de la base de données.
  </para>

 </sect2>
 <sect2 id="sepgsql-installation">
  <title>Installation</title>

  <para>
    <filename>sepgsql</filename> peut seulement être utilisé sur
    <productname>Linux</productname> 2.6.28 ou ultérieur, avec
    <productname>SELinux</productname> activé. Il n'est pas disponible
    sur les autres plateformes. Vous aurez aussi besoin
    de <productname>libselinux</productname> ou ultérieur et de
    <productname>selinux-policy</productname> 2.0.99 ou ultérieur
    (même si certaines distributions peuvent proposer les règles nécessaires
    dans des versions antérieures de politique).
  </para>

  <para>
   La commande <command>sestatus</command> vous permet de vérifier le
   statut de <productname>SELinux</productname>. Voici un affichage
   standard&nbsp;:
<screen>
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</screen>
   Si <productname>SELinux</productname> est désactivé ou non installé,
   vous devez tout d'abord configurer ce produit avant d'utiliser ce
   module.
  </para>

  <para>
   Pour construire ce module, ajoutez l'option <literal>--with-selinux</literal>
   dans votre commande <literal>configure</literal> lors de la compilation
   de PostgreSQL. Assurez-vous que le RPM <filename>libselinux-devel</filename>
   est installé au moment de la construction.
  </para>

  <para>
   Pour utiliser ce module, vous devez ajouter <literal>sepgsql</literal>
   dans le paramètre <xref linkend="guc-shared-preload-libraries"/> du
   fichier <filename>postgresql.conf</filename>. Le module ne
   fonctionnera pas correctement s'il est chargé d'une autre façon. Une
   fois que le module est chargé, vous devez exécuter
   <filename>sepgsql.sql</filename> dans chaque base de données. Cela
   installera les fonctions nécessaires à la gestion des labels de
   sécurité et affectera des labels initiaux de sécurité.
  </para>

  <para>
   Voici un exemple montrant comment initialiser un répertoire de données
   avec les fonctions <filename>sepgsql</filename> et les labels de
   sécurité installés. Ajustez les chemins de façon approprié pour que
   cela corresponde à votre installation&nbsp;:
   </para>
 
 <screen>
$ export PGDATA=/path/to/data/directory
 $ initdb
 $ vi $PGDATA/postgresql.conf
  modifiez
    #shared_preload_libraries = ''                # (change requires restart)
  en
    shared_preload_libraries = 'sepgsql'          # (change requires restart)
 $ for DBNAME in template0 template1 postgres; do
    postgres --single -F -c exit_on_error=true $DBNAME \
      &lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
   done
 </screen>

  <para>
   Notez que vous pourriez voir les notifications suivantes, suivant la
   combinaison de versions particulières de
   <productname>libselinux</productname> et de
   <productname>selinux-policy</productname>.
<screen>
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 36 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 37 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 38 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 39 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 40 has invalid object type db_language
</screen>
   Ces messages ne sont graves et peuvent être ignorés sans conséquence.
  </para>

  <para>
   Si le processus d'installation se termine sans erreur, vous pouvez
   commencer à lancer le serveur normalement.
  </para>
 </sect2>

 <sect2 id="sepgsql-regression">
  <title>Tests de régression</title>
  <para>
   Dû à la nature de <productname>SELinux</productname>, exécuter les
   tests de régression pour <filename>sepgsql</filename> nécessite
   quelques étapes de configuration supplémentaires, certaines se faisant en
   tant qu'utilisateur root. Les tests de régression ne seront pas exécutés
   par une commande <literal>make check</literal> ou <literal>make
   installcheck</literal> ordinaire&nbsp;; vous devez faire la configuration
   puis appeler le script de test manuellement. Les tests s'exécuteront dans
   le répertoire <filename>contrib/sepgsql</filename> du répertoire des
   sources de PostgreSQL, préalablement configuré. Bien que cela nécessite
   un arbre de construction, les tests sont conçus pour être exécutés par un
   serveur déjà installé, donc comparable à <literal>make installcheck</literal>,
   et non pas <literal>make check</literal>.
  </para>

  <para>
   Tout d'abord, configurez <filename>sepgsql</filename> dans une base de
   données fonctionnelle d'après les instructions comprises dans <xref
   linkend="sepgsql-installation"/>. Notez que l'utilisateur du système
   d'exploitation doit être capable de se connecter à la base de données en
   tant que superutilisateur sans authentification par mot de passe.
  </para>

  <para>
   Ensuite, construisez et installez le paquet de politique pour les
   tests de régression. Le fichier <filename>sepgsql-regtest</filename>
   est un paquet de politique à but spécial. Il fournit un ensemble de
   règles à autoriser pendant les tests de régression. Il doit être
   construit à partir du fichier source de politique
   <filename>sepgsql-regtest.te</filename>, ce qui se fait en utilisant
   <command>make</command> avec un fichier Makefile fourni par SELinux.
   Vous aurez besoin de localiser le Makefile approprié sur votre
   système&nbsp;; le chemin affiché ci-dessous est seulement un exemple.
   Une fois construit, installez ce paquet de politique en utilisant la
   commande
   <command>semodule</command>, qui charge les paquets de politique fournis
   dans le noyau. Si ce paquet est correctement
   installé, <literal><command>semodule</command> -l</literal> doit lister
   sepgsql-regtest comme un paquet de politique disponible&nbsp;:
  </para>

<screen>
$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.04
</screen>

  <para>
   For security reasons, the rules in <filename>sepgsql-regtest</filename>
   are not enabled by default. Le paramètre
   <literal>sepgsql_regression_test_mode</literal> active les
   règles pour le lancement des tests de régression. Il peut être
   activé en utilisant la commande <command>setsebool</command>&nbsp;:
  </para>

<screen>
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
</screen>

  <para>
   Ensuite, vérifiez que votre shell est exécuté dans le domaine
   <literal>unconfined_t</literal>&nbsp;:
  </para>
<screen>
$ ./test_sepgsql
</screen>

  <para>
   Ce script tentera de vérifier que vous avez fait correctement toutes
   les étapes de configuration, puis il lancera les tests de régression
   du module <filename>sepgsql</filename>.
  </para>

  <para>
   Une fois les tests terminés, il est recommandé de désactiver le
   paramètre <literal>sepgsql_regression_test_mode</literal>&nbsp;:
   </para>
 
 <screen>
$ sudo setsebool sepgsql_regression_test_mode off
</screen>

  <para>
   Vous pouvez préférer supprimer complètement la politique
   <filename>sepgsql-regtest</filename>&nbsp;:
  </para>

<screen>
$ sudo semodule -r sepgsql-regtest
 </screen>
 </sect2>

 <sect2 id="sepgsql-parameters">
  <title>Paramètres GUC</title>

  <variablelist>
   <varlistentry id="guc-sepgsql-permissive" xreflabel="sepgsql.permissive">
    <term><varname>sepgsql.permissive</varname> (<type>boolean</type>)</term>
    <indexterm>
     <primary>paramètre de configuration <varname>sepgsql.permissive</varname></primary>
    </indexterm>
    <listitem>
     <para>
      Ce paramètre active <productname>sepgsql</productname> pour
      qu'il fonctionne en mode permissif, quelque soit la configuration
      du système. La valeur par défaut est off.
      Ce paramètre es configurable dans le fichier
      <filename>postgresql.conf</filename> et sur la ligne de commande.
     </para>

     <para>
      Quand ce paramètre est activé, <productname>sepgsql</productname>
      fonctionne en mode permissif, même si SELinux
      fonctionne en mode forcé. Ce paramètre est utile principalement
      pour des tests.
     </para>
    </listitem>

   </varlistentry>
   <varlistentry id="guc-sepgsql-debug-audit" xreflabel="sepgsql.debug_audit">
    <term><varname>sepgsql.debug_audit</varname> (<type>boolean</type>)</term>
    <indexterm>
     <primary>paramètre de configuration <varname>sepgsql.debug_audit</varname></primary>
    </indexterm>
    <listitem>
     <para>
      Ce paramètre active l'affichage de messages d'audit quelque soit
      la configuration de la politique. La valeur par défaut est
      off, autrement dit les messages seront affichés suivant la
      configuration du système.
     </para>

     <para>
      La politique de sécurité de <productname>SELinux</productname> a
      aussi des règles pour contrôler la trace des accès. Par défaut,
      les violations d'accès sont tracées, contrairement aux accès
      autorisés.
     </para>

     <para>
      Ce paramètre force l'activation de toutes les traces, quelque soit
      la politique du système.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-features">
  <title>Fonctionnalités</title>
  <sect3>
   <title>Classes d'objet contrôlé</title>
   <para>
    Le modèle de sécurité <productname>SELinux</productname> décrit toutes
    les règles de contrôle d'accès comme des relations entre une entité
    sujet (habituellement le client d'une base) et une entité objet
    (tel que l'objet base de données). Les
    deux sont identifiés par un label de sécurité. Si un accès à un
    objet sans label est tenté, l'objet est traité comme si le label
    <literal>unlabeled_t</literal> lui est affecté.
   </para>

   <para>
    Actuellement, <filename>sepgsql</filename> autorise l'affectation
    de label de sécurité aux schémas, tables, colonnes, séquences, vues
    et fonctions. Quand <filename>sepgsql</filename> est en cours
    d'utilisation, des labels de sécurité sont automatiquement affectés
    aux objets de la base au moment de leur création. Ce label est appelé
    un label de sécurité par défaut et est configuré par la politique de
    sécurité du système, qui prend en entrée le label du créateur et le
    label affecté à l'objet parent du nouvel objet.
   </para>

   <para>
    Un nouvel objet base de données hérite en gros du label de sécurité
    de l'objet parent, sauf quand la politique de sécurité a des règles
    spéciales, connues sous le nom de règles de transition, auquel cas
    un label différent est affecté. Pour les schémas, l'objet parent est
    la base de données&nbsp;; pour les tables, séquences, vues et
    fonctions, il s'agit du schéma&nbsp;; pour les colonnes, il s'agit
    de la table.
   </para>
  </sect3>

  <sect3>
   <title>Droits DML</title>

   <para>
    Pour les tables, <literal>db_table:select</literal>, <literal>db_table:insert</literal>,
    <literal>db_table:update</literal> ou <literal>db_table:delete</literal>
    sont vérifiés pour toutes les tables cibles référencées, suivant l'ordre
    de l'instruction. De plus, <literal>db_table:select</literal> est
    aussi vérifié pour toutes les tables qui contiennent des colonnes
    référencées dans la clause <literal>WHERE</literal> ou
    <literal>RETURNING</literal>, comme source de données d'un
    <literal>UPDATE</literal>, et ainsi de suite.
   </para>

   <para>
    Column-level permissions will also be checked for each referenced column.
    <literal>db_column:select</literal> is checked on not only the columns being
    read using <literal>SELECT</literal>, but those being referenced in other DML
    statements; <literal>db_column:update</literal> or <literal>db_column:insert</literal>
    will also be checked for columns being modified by <literal>UPDATE</literal> or
    <literal>INSERT</literal>.
   </para>

   <para>
    Bien sûr, il vérifie aussi <literal>db_column:update</literal> ou
    <literal>db_column:insert</literal> sur la colonne en cours de
    modification par <literal>UPDATE</literal> ou <literal>INSERT</literal>.
   </para>

   <para>
     For example, consider:
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>

    Here, <literal>db_column:update</literal> will be checked for
    <literal>t1.x</literal>, since it is being updated,
    <literal>db_column:{select update}</literal> will be checked for
    <literal>t1.y</literal>, since it is both updated and referenced, and
    <literal>db_column:select</literal> will be checked for <literal>t1.z</literal>, since
    it is only referenced.
    <literal>db_table:{select update}</literal>
    vérifiera aussi la table.
   </para>

   <para>
    Pour les séquences, <literal>db_sequence:get_value</literal> est
    vérifié quand nous référençons un objet séquence en utilisant
    <literal>SELECT</literal>&nbsp;; néanmoins, notez que nous ne vérifions
    pas les droits d'exécution sur les fonctions correspondantes, par
    exemple <literal>lastval()</literal>.
   </para>

   <para>
    Pour les vues, <literal>db_view:expand</literal> devrait être
    vérifié, et ensuite tous les autres droits des objets dus à
    l'aplatissement de la vue, individuellement.
   </para>

   <para>
    Pour les fonctions, <literal>db_procedure:{execute}</literal> est
    défini mais n'est pas vérifié dans cettet version.
   </para>

   <para>
    Le client doit être autorisé à accéder à toutes les tables et colonnes
    référencées, même si elles proviennent de vues qui ont été aplaties,
    pour pouvoir appliquer des règles de contrôles d'accès cohérentes
    indépendamment de la manère dont le contenu des tables est référencé.
   </para>

   <para>
    Le système des droits de la base, par défaut, autorise les
    superutilisateurs de la base à modifier les catalogues systèmes en
    utilisant des commandes DML, et de référencer ou modifier les tables
    TOAST. Ces opérations sont interdites quand
    <filename>sepgsql</filename> est activé.
   </para>
  </sect3>

  <sect3>
   <title>Droits DDL</title>
   <para>
    <productname>SELinux</productname> defines several permissions to control common
    operations for each object type; such as creation, alter, drop and
    relabel of security label. In addition, several object types have
    special permissions to control their characteristic operations; such as
    addition or deletion of name entries within a particular schema.
   </para>
   <para>
    When a <literal>CREATE</literal> command is executed, <literal>create</literal> will
    be checked on the object being constructed for each object types.
    A default security label will be assigned to the new database object,
    and the <literal>create</literal> permission will be checked on the pair
    of security label of the client and the new object itself.
    We consider <xref linkend="sql-createtable"/> to construct a table and
    underlying columns at the same time, so it requires the users to have
    permission to create both the table and its columns.
   </para>
   <para>
    A few additional checks are applied depending on object types.
    On <xref linkend="sql-createdatabase"/>, <literal>getattr</literal> permission
    will be checked on the source or template database of the new database,
    not only <literal>create</literal> on the new database.
    On creation of objects within a particular schema (tables, views,
    sequences and procedures), <literal>add_name</literal> will be also checked
    on the schema, not only <literal>create</literal> on the new object itself.
   </para>

   <para>
    When <literal>DROP</literal> command is executed, <literal>drop</literal> will be
    checked on the object being removed for each object types.  Permissions
    will not be checked for objects dropped indirectly via <literal>CASCADE</literal>.
    Deletion of objects contained within a particular schema (tables, views,
    sequences and procedures) additionally requires
    <literal>remove_name</literal> on the schema.
   </para>

   <para>
    Quand la commande <xref linkend="sql-security-label"/> est exécutée,
    <literal>setattr</literal> et <literal>relabelfrom</literal> devraient
    être vérifiés sur l'objet en cours de labelisation avec un ancien
    label de sécurité, puis <literal>relabelto</literal> sur le nouveau
    label de sécurité fourni.
   </para>

   <para>
    Dans le cas où plusieurs fournisseurs de labels sont installés et
    que l'utilisateur essaie de configurer un label de sécurité qui n'est
    pas géré par <productname>SELinux</productname>, seul
    <literal>setattr</literal> devrait être vérifié ii. Ceci n'est pas
    fait dû à des restrictions de l'implémentation.
   </para>
  </sect3>

  <sect3>
   <title>Procédures de confiance</title>
   <para>
    Les procédures de confiance sont similaires aux fonctions dont la
    sécurité est définie à la création ou aux commandes set-uid. 
    <productname>SELinux</productname> propose une fonctionnalité qui
    permet d'autoriser un code de confiance à s'exécuter en utilisant
    un label de sécurité différent de celui du client, généralement pour
    donner un accès hautement contrôlé à des données sensibles (par
    exemple, des lignes peuvent être omises ou la précision des valeurs
    stockées peut être réduite). Que la fonction agisse ou pas comme
    une procédure de confiance est contrôlé par son label de sécurité et
    la politique de sécurité du système d'exploitation. Par exemple&nbsp;:
   </para>

<screen>
postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
</screen>

   <para>
    Les opérations ci-dessus doivent être réalisées par un utilisateur
    administrateur.
   </para>

<screen>
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-----+--------+---------------------
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)
</screen>

   <para>
    Dans ce cas, un utilisateur standard ne peut pas faire référence à
    <literal>customer.credit</literal> directement mais une procédure de
    confiance comme <literal>show_credit</literal> lui permet d'afficher
    le numéro de carte de crédit des clients, avec quelques chiffres
    masqués.
   </para>
  </sect3>

  <sect3>
   <title>Dynamic Domain Transitions</title>
   <para>
    It is possible to use SELinux's dynamic domain transition feature
    to switch the security label of the client process, the client domain,
    to a new context, if that is allowed by the security policy.
    The client domain needs the <literal>setcurrent</literal> permission and also
    <literal>dyntransition</literal> from the old to the new domain.
   </para>
   <para>
    Dynamic domain transitions should be considered carefully, because they
    allow users to switch their label, and therefore their privileges,
    at their option, rather than (as in the case of a trusted procedure)
    as mandated by the system.
    Thus, the <literal>dyntransition</literal> permission is only considered
    safe when used to switch to a domain with a smaller set of privileges than
    the original one. For example:
   </para>
<screen>
regression=# select sepgsql_getcon();
                    sepgsql_getcon
-------------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c4');
 sepgsql_setcon 
----------------
 t
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c1023');
ERROR:  SELinux: security policy violation
</screen>
   <para>
    In this example above we were allowed to switch from the larger MCS
    range <literal>c1.c1023</literal> to the smaller range <literal>c1.c4</literal>, but
    switching back was denied.
   </para>
   <para>
    A combination of dynamic domain transition and trusted procedure
    enables an interesting use case that fits the typical process life-cycle
    of connection pooling software.
    Even if your connection pooling software is not allowed to run most
    of SQL commands, you can allow it to switch the security label
    of the client using the <literal>sepgsql_setcon()</literal> function
    from within a trusted procedure; that should take some
    credential to authorize the request to switch the client label.
    After that, this session will have the privileges of the target user,
    rather than the connection pooler.
    The connection pooler can later revert the security label change by
    again using <literal>sepgsql_setcon()</literal> with
    <literal>NULL</literal> argument, again invoked from within a trusted
    procedure with appropriate permissions checks.
    The point here is that only the trusted procedure actually has permission
    to change the effective security label, and only does so when given proper
    credentials.  Of course, for secure operation, the credential store
    (table, procedure definition, or whatever) must be protected from
    unauthorized access.
   </para>
  </sect3>

  <sect3>
   <title>Divers</title>
   <para>
    Nous rejetons la commande <xref linkend="sql-load"/> car tout module
    chargé pourrait facilement court-circuiter la politique de sécurité.
   </para>

  </sect3>
 </sect2>

 <sect2 id="sepgsql-functions">
  <title>Sepgsql Functions</title>
  <para>
   <xref linkend="sepgsql-functions-table"/> shows the available functions.
  </para>

  <table id="sepgsql-functions-table">
   <title>Sepgsql Functions</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry><literal>sepgsql_getcon() returns text</literal></entry>
      <entry>
       Returns the client domain, the current security label of the client.
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_setcon(text) returns bool</literal></entry>
      <entry>
       Switches the client domain of the current session to the new domain,
       if allowed by the security policy.
       It also accepts <literal>NULL</literal> input as a request to transition
       to the client's original domain.
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_mcstrans_in(text) returns text</literal></entry>
      <entry>Translates the given qualifies MLS/MCS range into raw format if
      the mcstrans daemon is running.
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_mcstrans_out(text) returns text</literal></entry>
      <entry>Translates the given raw MCS/MCS range into qualified format if
      the mcstrans daemon is running.
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_restorecon(text) returns bool</literal></entry>
      <entry>
       Sets up initial security labels for all objects within the
       current database. The argument may be NULL, or the name of a specfile
       to be used as alternative of the system default.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="sepgsql-limitations">
  <title>Limitations</title>

  <variablelist>
   <varlistentry>
    <term>Droits DDL</term>
    <listitem>
     <para>
      Dû aux restrictions d'implémentations, certaines opérations DDL 
      ne vérifient pas les droits.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Droits DCL</term>
    <listitem>
     <para>
      Dû aux restrictions d'implémentations, les droits DCL
      ne vérifient pas les droits.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Contrôle d'accès au niveau ligne</term>
    <listitem>
     <para>
      <productname>PostgreSQL</productname> ne supporte pas le contrôle
      d'accès au niveau ligne. Du coup, <filename>sepgsql</filename>
      ne le supporte pas non plus.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Canaux cachés</term>
    <listitem>
     <para>
      <filename>sepgsql</filename> n'essaie pas de cacher
      l'existence d'un objet particulier, même si l'utilisateur n'est
      pas autorisé à y accéder. Par exemple, nous pouvons inférer
      l'existence d'un objet invisible suite à un conflit de clé primaire,
      à des violations de clés étrangèes et ainsi de suite, même si nous
      ne pouvons pas accéder au contenu de ces objets. L'existence d'une
      table secrète ne peut pas être caché. Nous ne faisons que
      verrouiller l'accès à son contenu.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-resources">
  <title>Ressources externes</title>
  <variablelist>
   <varlistentry>
    <term><ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL">SE-PostgreSQL Introduction</ulink></term>
    <listitem>
     <para>
      Cette page wiki fournit un bref aperçu, le concept de la sécurité,
      l'architecture, l'administration et les fonctionnalités futures.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-user-guide/">Fedora SELinux User Guide</ulink></term>
    <listitem>
     <para>
      Ce document fournit une connaissance large pour administrer
      <productname>SELinux</productname> sur vos systèmes.
      Il cible principalement Fedora mais n'y est pas limité.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-faq">Fedora SELinux FAQ</ulink></term>
    <listitem>
     <para>
      Ce document répond aux questions fréquemment posées sur
      <productname>SELinux</productname>.
      Il cible principalement Fedora mais n'y est pas limité.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-author">
  <title>Auteur</title>
  <para>
   KaiGai Kohei <email>kaigai@ak.jp.nec.com</email>
  </para>
 </sect2>
</sect1>
